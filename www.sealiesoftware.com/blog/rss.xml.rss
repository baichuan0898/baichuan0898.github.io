<?xml version="1.0"?>
<!-- RSS generated by my own two hands and bloggerizer.pl -->
<rss version="2.0">
  <channel>
    <title>Hamster Emporium</title>
    <link>http://www.sealiesoftware.com/blog/</link>
    <description>Greg Parker's web log</description>
    <item>
      <title>Objective-C and fork() in macOS 10.13</title>
      <link>http://www.sealiesoftware.com/blog/archive/2017/6/5/Objective-C_and_fork_in_macOS_1013.html</link>
      <pubDate>5 Jun 2017 24:05 PDT</pubDate>
      <description>    &lt;p&gt;
      The rules for using Objective-C between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; have 
      changed in macOS 10.13. Incorrect code that happened to work most 
      of the time in the past may now fail. Some workarounds are available.
&lt;h4&gt;&lt;code&gt;fork()&lt;/code&gt; and Objective-C&lt;/h4&gt;
    &lt;p&gt;
      Before macOS 10.13, the Objective-C runtime did not support use 
      between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; in the child process of a multithreaded 
      parent process. Calling any Objective-C method in that interval 
      was not allowed. Most of the time it might work. Sometimes it would fail: for example, if a 
      thread in the parent process happened to be holding one of 
      the Objective-C runtime's locks when the &lt;code&gt;fork()&lt;/code&gt; occurred, 
      the child process would deadlock when it tried to take that lock.
    &lt;p&gt;
      As of macOS 10.13, the Objective-C runtime now supports use between
      &lt;code&gt;fork()&lt;/code&gt;
      and &lt;code&gt;exec()&lt;/code&gt; in applications built with the 10.13 SDK. There are
      restrictions involving &lt;code&gt;+initialize&lt;/code&gt; methods. Previously incorrect code may
      now be correct, or it may fail consistently due to &lt;code&gt;+initialize&lt;/code&gt; behavior.
    &lt;p&gt;
      Note that the Objective-C classes defined by the OS frameworks remain &lt;code&gt;fork&lt;/code&gt;-unsafe. As a first approximation it is still incorrect to do anything between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;.

      &lt;h4&gt;&lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt;&lt;/h4&gt;
    &lt;p&gt;
      &lt;code&gt;+initialize&lt;/code&gt; methods still have restrictions around &lt;code&gt;fork()&lt;/code&gt;. The problem is that the thread-safety guarantees of &lt;code&gt;+initialize&lt;/code&gt; implicitly introduce locks around state that the Objective-C runtime does not control. There is no good way to make &lt;code&gt;+initialize&lt;/code&gt; both thread-safe and &lt;code&gt;fork&lt;/code&gt;-safe. Instead the Objective-C runtime simply halts the process instead of running any &lt;code&gt;+initialize&lt;/code&gt; override in the child process: 
&lt;p&gt;
&lt;code&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; +[SomeClass initialize] may have been in progress in another thread when &lt;code&gt;fork()&lt;/code&gt; was called. We cannot safely call it or ignore it in the &lt;code&gt;fork()&lt;/code&gt; child process. Crashing instead.
&lt;/code&gt;
&lt;p&gt;
If you have a class that needs to be &lt;code&gt;fork&lt;/code&gt;-safe and also overrides &lt;code&gt;+initialize&lt;/code&gt;, you can use the "prepare" side of &lt;code&gt;pthread_atfork()&lt;/code&gt; to force &lt;code&gt;+initialize&lt;/code&gt; to run. Then the child process will see a consistent state without a &lt;code&gt;+initialize&lt;/code&gt; deadlock threat.

&lt;h4&gt;Workarounds for compatibility&lt;/h4&gt;
    &lt;p&gt;
      There are three ways to get the old behavior back for source- or binary-compatibility.
      &lt;ul&gt;
      &lt;li&gt;Build your app with an SDK older than macOS 10.13.
&lt;li&gt;Define environment variable &lt;code&gt;OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES&lt;/code&gt;.
&lt;li&gt;Add a &lt;code&gt;__DATA,__objc_fork_ok&lt;/code&gt; section to your executable.
&lt;/ul&gt;
&lt;p&gt;
Be warned that incorrect code is more likely to deadlock on macOS 10.13 than before, even with one of these workarounds in place.

&lt;h4&gt;Scripting languages&lt;/h4&gt;
&lt;p&gt;
  Some scripting languages use &lt;code&gt;fork()&lt;/code&gt; without &lt;code&gt;exec()&lt;/code&gt; as a substitute for threads. Python's &lt;code&gt;multiprocessing&lt;/code&gt; module is one example. The &lt;code&gt;OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES&lt;/code&gt; environment variable described above may temporarily get your scripts running again.

&lt;h4&gt;Summary of fixes&lt;/h4&gt;
&lt;p&gt;
Possible fixes for &lt;code&gt;fork&lt;/code&gt;-safety problems, from best to worst:
&lt;ol&gt;
&lt;li&gt;Use &lt;code&gt;NSTask&lt;/code&gt; or &lt;code&gt;posix_spawn()&lt;/code&gt; instead of &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;.
&lt;li&gt;Do nothing between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;.
&lt;li&gt;Use only async-signal-safe operations between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;.
&lt;li&gt;Use ObjC classes with no &lt;code&gt;+initialize&lt;/code&gt; overrides between &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;.
&lt;li&gt;Use &lt;code&gt;pthread_atfork()&lt;/code&gt; to force your &lt;code&gt;+initialize&lt;/code&gt; methods to run before &lt;code&gt;fork()&lt;/code&gt;.
&lt;li&gt;Define environment variable &lt;code&gt;OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES&lt;/code&gt;, or add a &lt;code&gt;__DATA,__objc_fork_ok&lt;/code&gt; section, or build using an SDK older than macOS 10.13. Then cross your fingers.
&lt;/ol&gt;
    &lt;/p&gt;
</description>
    </item>
    <item>
      <title>[objc explain]: Non-pointer isa</title>
      <link>http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</link>
      <pubDate>24 Sep 2013 1:27 PDT</pubDate>
      <description>      &lt;p&gt;
	On iOS for arm64, the isa field of Objective-C objects is no longer a pointer.
	&lt;h4&gt;Say what?&lt;/h4&gt;
      &lt;p&gt;
	On iOS for arm64, the isa field of Objective-C objects is no longer a pointer.	
	&lt;h4&gt;If it's not a pointer anymore, what is it?&lt;/h4&gt;
      &lt;p&gt;
	Some of the bits still encode the pointer to the object's class. But neither OS X nor iOS actually uses all 64 bits of virtual address space. The Objective-C runtime may use these extra bits to store per-object data like its retain count or whether it has been weakly referenced.
	&lt;h4&gt;Why change it?&lt;/h4&gt;
      &lt;p&gt;
	Performance. Re-purposing these otherwise unused bits increases speed and decreases memory size. On iOS 7 the focus is on optimizing retain/release and alloc/dealloc.
	&lt;h4&gt;What does this mean for my code?&lt;/h4&gt;
      &lt;p&gt;
	Don't read &lt;code&gt;obj-&gt;isa&lt;/code&gt; directly. The compiler will complain if you do. &lt;font size=-1&gt;Trust the Compiler. The Compiler is your friend.&lt;/font&gt; Use &lt;code&gt;[obj class]&lt;/code&gt; or &lt;code&gt;object_getClass(obj)&lt;/code&gt; instead. 
      &lt;p&gt;
	Don't write &lt;code&gt;obj-&gt;isa&lt;/code&gt; directly. Use &lt;code&gt;object_setClass()&lt;/code&gt; instead.
      &lt;p&gt;
	If you override &lt;code&gt;+allocWithZone:&lt;/code&gt;, you may initialize your object's isa field to a "raw" isa pointer. If you do, no extra data will be stored in that isa field and you may suffer the slow path through code like retain/release. To enable these optimizations, instead set the isa field to zero (if it is not already) and then call &lt;code&gt;object_setClass()&lt;/code&gt;.
      &lt;p&gt;
	If you override retain/release to implement a custom inline retain count, consider removing that code in favor of the runtime's implementation.
      &lt;p&gt;
	The 64-bit iOS simulator currently does not use non-pointer isa. Test your code on a real arm64 device.
	&lt;h4&gt;What does this mean for debugging?&lt;/h4&gt;
      &lt;p&gt;
	The debugger knows how to decode the class from the isa field. You should not need to examine it directly in most cases.
      &lt;p&gt;
	You can run your code with environment variable &lt;code&gt;OBJC_DISABLE_NONPOINTER_ISA=YES&lt;/code&gt; to disable non-pointer isa for all classes. If your code works with this set and fails without it, you may be incorrectly accessing an isa field directly somewhere.
      &lt;p&gt;
	If you are writing a debugger-like tool, the Objective-C runtime exports some variables to help decode isa fields. &lt;code&gt;objc_debug_isa_class_mask&lt;/code&gt; describes which bits are the class pointer: &lt;code&gt;(isa &amp; class_mask) == &lt;/code&gt;class pointer. &lt;code&gt;objc_debug_isa_magic_mask&lt;/code&gt; and &lt;code&gt;objc_debug_isa_magic_value&lt;/code&gt; describe some bits that help distinguish valid isa fields from other invalid values: &lt;code&gt;(isa &amp; magic_mask) == magic_value&lt;/code&gt; for isa fields that are not raw class pointers. These variables may change in the future so do not use them in application code.
	&lt;h4&gt;No seriously, what do each of the bits mean?&lt;/h4&gt;
      &lt;p&gt;
	For entertainment purposes only. These values will change in future OS versions. I think they already have changed, actually.
	&lt;table&gt;
	  &lt;tr&gt;&lt;td colspan=2 align=center&gt;(LSB)&lt;td&gt;&amp;nbsp;&lt;td&gt;&amp;nbsp;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;indexed&lt;/code&gt;&lt;td&gt;&lt;code&gt;0&lt;/code&gt; is raw isa, &lt;code&gt;1&lt;/code&gt; is non-pointer isa.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;has_assoc&lt;/code&gt;&lt;td&gt;Object has or once had an associated reference. Object with no associated references can deallocate faster.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;has_cxx_dtor&lt;/code&gt;&lt;td&gt;Object has a C++ or ARC destructor. Objects with no destructor can deallocate faster.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;30&lt;td&gt;bits&lt;td&gt;&lt;code&gt;shiftcls&lt;/code&gt;&lt;td&gt;Class pointer's non-zero bits.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;9&lt;td&gt;bits&lt;td&gt;&lt;code&gt;magic&lt;/code&gt;&lt;td&gt;Equals &lt;code&gt;0xd2&lt;/code&gt;. Used by the debugger to distinguish real objects from uninitialized junk.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;weakly_referenced&lt;/code&gt;&lt;td&gt;Object is or once was pointed to by an ARC weak variable. Objects not weakly referenced can deallocate faster.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;deallocating&lt;/code&gt;&lt;td&gt;Object is currently deallocating.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;1&lt;td&gt;bit&lt;td&gt;&lt;code&gt;has_sidetable_rc&lt;/code&gt;&lt;td&gt;Object's retain count is too large to store inline.&lt;/tr&gt;
	  &lt;tr&gt;&lt;td align=right&gt;19&lt;td&gt;bits&lt;td&gt;&lt;code&gt;extra_rc&lt;/code&gt;&lt;td&gt;Object's retain count above 1. (For example, if &lt;code&gt;extra_rc&lt;/code&gt; is 5 then the object's real retain count is 6.)&lt;/tr&gt;
	  &lt;tr&gt;&lt;td colspan=2 align=center&gt;(MSB)&lt;td&gt;&amp;nbsp;&lt;td&gt;&amp;nbsp;
	&lt;/table&gt;
      &lt;p&gt;
</description>
    </item>
    <item>
      <title>[objc explain]: So you crashed in objc_msgSend(): iPhone 5s Edition</title>
      <link>http://www.sealiesoftware.com/blog/archive/2013/09/12/objc_explain_So_you_crashed_in_objc_msgSend_iPhone_5s_Edition.html</link>
      <pubDate>12 Sep 2013 24:45 PDT</pubDate>
      <description>      &lt;p&gt;
	&lt;a
	href="http://sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html"&gt;So
	you crashed in objc_msgSend()&lt;/a&gt; has been updated with register
	usage for iPhone 5s's ARM64 processor. The table now looks like this:
	&lt;table border=1 cellspacing=0 cellpadding=4&gt;
	  &lt;th&gt;&lt;td align=center colspan=2&gt;&lt;code&gt;objc_msgSend&lt;/code&gt;&lt;br&gt;&lt;code&gt;objc_msgSend_fpret&lt;/code&gt;&lt;/td&gt;
	    &lt;td align=center colspan=2&gt;&lt;code&gt;objc_msgSend_stret&lt;/code&gt;&lt;/td&gt;&lt;/th&gt;
	  &lt;tr&gt;&lt;td align=center&gt;&amp;nbsp;&lt;/td&gt;&lt;td align=center&gt;&lt;code&gt;receiver&lt;/code&gt;&lt;/td&gt;&lt;td align=center&gt;&lt;code&gt;SEL&lt;/code&gt;&lt;/td&gt;&lt;td align=center&gt;&lt;code&gt;receiver&lt;/code&gt;&lt;/td&gt;&lt;td align=center&gt;&lt;code&gt;SEL&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;i386&lt;/td&gt;&lt;td align=center&gt;eax*&lt;/td&gt;&lt;td align=center&gt;ecx&lt;/td&gt;
	    &lt;td align=center&gt;eax*&lt;/td&gt;&lt;td align=center&gt;ecx&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;x86_64&lt;/td&gt;&lt;td align=center&gt;rdi&lt;/td&gt;&lt;td align=center&gt;rsi&lt;/td&gt;
	    &lt;td align=center&gt;rsi&lt;/td&gt;&lt;td align=center&gt;rdx&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;ppc&lt;/td&gt;&lt;td align=center&gt;r3&lt;/td&gt;&lt;td align=center&gt;r4&lt;/td&gt;
	    &lt;td align=center&gt;r4&lt;/td&gt;&lt;td align=center&gt;r5&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;ppc64&lt;/td&gt;&lt;td align=center&gt;r3&lt;/td&gt;&lt;td align=center&gt;r4&lt;/td&gt;
	    &lt;td align=center&gt;r4&lt;/td&gt;&lt;td align=center&gt;r5&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;arm&lt;/td&gt;&lt;td align=center&gt;r0&lt;/td&gt;&lt;td align=center&gt;r1&lt;/td&gt;
	    &lt;td align=center&gt;r1&lt;/td&gt;&lt;td align=center&gt;r2&lt;/td&gt;&lt;/tr&gt;
	  &lt;tr&gt;&lt;td&gt;arm64&lt;/td&gt;&lt;td align=center&gt;x0&lt;/td&gt;&lt;td align=center&gt;x1&lt;/td&gt;
	    &lt;td align=center&gt;&amp;mdash;&lt;/td&gt;&lt;td align=center&gt;&amp;mdash;&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
      &lt;/p&gt;
</description>
    </item>
    <item>
      <title>[objc explain]: return value of message to nil</title>
      <link>http://www.sealiesoftware.com/blog/archive/2012/2/29/objc_explain_return_value_of_message_to_nil.html</link>
      <pubDate>29 Feb 2012 14:40 PDT</pubDate>
      <description>      &lt;h4&gt;LLVM Compiler 3.0 (Xcode 4.2) or later&lt;/h4&gt;
      &lt;p&gt;
	Integers up to 64 bits: 0&lt;br&gt;
	Floating-point up to &lt;code&gt;long double&lt;/code&gt;: 0.0&lt;br&gt;
	Pointers: &lt;code&gt;nil&lt;/code&gt;&lt;br&gt;
	Structs: &lt;code&gt;{0}&lt;/code&gt;&lt;br&gt;
	Any &lt;code&gt;_Complex&lt;/code&gt; type: &lt;code&gt;{0, 0}&lt;/code&gt;&lt;br&gt;
      &lt;/p&gt;
      &lt;h4&gt;Notes&lt;/h4&gt;
      &lt;p&gt;
	C++ objects returned by value are initialized to &lt;code&gt;{0}&lt;/code&gt;, even if the type has a default constructor that does something else. This may be fixed in the future.&lt;br&gt;
	Struct return is undefined if you call &lt;code&gt;objc_msgSend_stret()&lt;/code&gt; directly.&lt;br&gt; 
	Struct return is undefined if you use an older compiler.&lt;br&gt;
	Floating-point return is undefined on Mac OS X 10.4 and earlier on Power PC.&lt;br&gt;
	&lt;code&gt;_Complex long double&lt;/code&gt; return is undefined if you use an older compiler.&lt;br&gt;
      &lt;/p&gt;
</description>
    </item>
    <item>
      <title>[objc explain]: objc_msgSend_vtable</title>
      <link>http://www.sealiesoftware.com/blog/archive/2011/06/17/objc_explain_objc_msgSend_vtable.html</link>
      <pubDate>17 Jun 2011 16:42 PDT</pubDate>
      <description>    &lt;p&gt;
      &lt;code&gt;objc_msgSend_vtable&lt;/code&gt; is a version
      of &lt;code&gt;objc_msgSend&lt;/code&gt; used to optimize a few of the most
      commonly called methods. 
    &lt;p&gt;
      Most Objective-C methods are dispatched using a hash table lookup
      inside &lt;code&gt;objc_msgSend&lt;/code&gt;. On x86_64, a few selectors can be
      dispatched using a C++-style virtual table: an array lookup, not a
      hash table. 
    &lt;p&gt;
      The compiler knows which selectors are optimized by the runtime. It
      compiles the call site differently,
      calling &lt;code&gt;objc_msgSend_fixup&lt;/code&gt; via a function pointer. At
      runtime, &lt;code&gt;objc_msgSend_fixup&lt;/code&gt; replaces the function
      pointer with one of the &lt;code&gt;objc_msgSend_vtable&lt;/code&gt; functions,
      if the called selector is one of the optimized selectors. 
    &lt;p&gt;
      C++ vtables are notoriously fragile: the array offsets for each
      virtual method are hardcoded into the generated code. Objective-C's
      vtables are not fragile. Each vtable is built at runtime and updated
      when method lists change. In theory even the set of optimized
      methods could be changed. The non-fragile flexibility costs an extra
      memory load during dispatch. 
    &lt;p&gt;
      Dispatch via vtable is faster than a hash table, but would consume
      tremendous amounts of memory if used everywhere. Objective-C's
      vtable implementation limits its use to a few selectors that are (1)
      implemented everywhere, but (2) rarely overridden. That means most
      classes share their superclass's vtable, which keeps memory costs
      low. 
    &lt;p&gt;
      A crash in any &lt;code&gt;objc_msgSend_vtable&lt;/code&gt; function should be
      debugged exactly like a crash in &lt;code&gt;objc_msgSend&lt;/code&gt;
      itself. They both crash for all of the same reasons, like incorrect
      memory management or memory smashers. 
    &lt;p&gt;
      Currently, the runtime uses sixteen
      different &lt;code&gt;objc_msgSend_vtable&lt;/code&gt; functions, one for each
      slot in the sixteen-entry vtable. 
    &lt;/p&gt;
    &lt;table border=1 cellspacing=0 cellpadding=4&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable0&lt;/code&gt;&lt;td&gt;&lt;code&gt;allocWithZone:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable1&lt;/code&gt;&lt;td&gt;&lt;code&gt;alloc&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable2&lt;/code&gt;&lt;td&gt;&lt;code&gt;class&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable3&lt;/code&gt;&lt;td&gt;&lt;code&gt;self&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable4&lt;/code&gt;&lt;td&gt;&lt;code&gt;isKindOfClass:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable5&lt;/code&gt;&lt;td&gt;&lt;code&gt;respondsToSelector:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable6&lt;/code&gt;&lt;td&gt;&lt;code&gt;isFlipped&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable7&lt;/code&gt;&lt;td&gt;&lt;code&gt;length&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable8&lt;/code&gt;&lt;td&gt;&lt;code&gt;objectForKey:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable9&lt;/code&gt;&lt;td&gt;&lt;code&gt;count&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable10&lt;/code&gt;&lt;td&gt;&lt;code&gt;objectAtIndex:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable11&lt;/code&gt;&lt;td&gt;&lt;code&gt;isEqualToString:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable12&lt;/code&gt;&lt;td&gt;&lt;code&gt;isEqual:&lt;/code&gt;
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable13&lt;/code&gt;&lt;td&gt;&lt;code&gt;retain&lt;/code&gt; (non-GC)&lt;br&gt;&lt;code&gt;hash&lt;/code&gt; (GC)
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable14&lt;/code&gt;&lt;td&gt;&lt;code&gt;release&lt;/code&gt; (non-GC)&lt;br&gt;&lt;code&gt;addObject:&lt;/code&gt; (GC)
      &lt;tr&gt;&lt;td&gt;&lt;code&gt;objc_msgSend_vtable15&lt;/code&gt;&lt;td&gt;&lt;code&gt;autorelease&lt;/code&gt; (non-GC)&lt;br&gt;&lt;code&gt;countByEnumeratingWithState:objects:count:&lt;/code&gt; (GC)
    &lt;/table&gt;
    &lt;p&gt;
       The vtable's contents differ for GC and non-GC, for obvious
       reasons. &lt;code&gt;-isFlipped&lt;/code&gt; is part of
       NSView. &lt;code&gt;-countByEnumeratingWithState:objects:count:&lt;/code&gt; is
       the fast enumeration implementation, including &lt;code&gt;for (x in
       y)&lt;/code&gt;. Together these methods make up roughly 30-50% of calls
       in typical Objective-C applications. 
</description>
    </item>
    <item>
      <title>Dr. Gregory Parker, Department of Diagnostic Engineering</title>
      <link>http://www.sealiesoftware.com/blog/archive/2010/09/01/Dr_Gregory_Parker_Department_of_Diagnostic_Engineering.html</link>
      <pubDate>01 Sep 2010 3:15 PDT</pubDate>
      <description>    &lt;p&gt;
      Last week, &lt;a href="http://twitter.com/rballard"&gt;Rick Ballard&lt;/a&gt; came by my office for a consult. He had caught Xcode at a crash in &lt;code&gt;objc_msgSend()&lt;/code&gt;. The crash looked like an intermittent problem that had been plaguing Xcode for months. So he called the local expert on debugging &lt;code&gt;objc_msgSend()&lt;/code&gt;. Dr. Gregory Parker, Department of Diagnostic Engineering.
    &lt;p&gt;
      The good news was that Rick's crash was reliably reproducible. Running tests on a live patient is better than performing an autopsy on a dead one. The bad news was that the obvious debugging tools had not helped. &lt;code&gt;NSZombieEnabled&lt;/code&gt; and &lt;code&gt;guardmalloc&lt;/code&gt; had turned up nothing, and &lt;code&gt;AUTO_USE_GUARDS=YES&lt;/code&gt; (the GC equivalent of &lt;code&gt;guardmalloc&lt;/code&gt;) just thrashed the machine for two hours before running out of address space.
    &lt;p&gt;
      &lt;a href="http://sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html"&gt;So you crashed in &lt;code&gt;objc_msgSend()&lt;/code&gt;&lt;/a&gt;. The selector was &lt;code&gt;-isAbsolutePath&lt;/code&gt;, which was reasonable but meant the debugger's backtrace was missing a frame. &lt;code&gt;objc_msgSend()&lt;/code&gt; had read the class from the object, read the method cache from the class, read a method from the method cache, and crashed while trying to read the &lt;code&gt;IMP&lt;/code&gt; from the method. Theory: either one of those data structures had been hit by a memory smasher, or the original object was bogus but happened to have dereferenceable pointers in the right places to survive that long. The method cache's mask was invalid - it should have been of the form 2&lt;sup&gt;n&lt;/sup&gt;-1 - so the failure must have been at or before that point in the chain.
    &lt;p&gt;
      The object pointer itself looked plausible. Theory: the object was valid, but a previous object at the same location had been used after being freed. We had the great luxury of a reproducible crash, so we turned on &lt;code&gt;MallocStackLoggingNoCompact&lt;/code&gt; and ran it again. That memory had only been used for one object, and it had not been deallocated. So the evidence did not support the use-after-free theory. But the history showed that the object had been allocated as an &lt;code&gt;NSPathStore2&lt;/code&gt; - an internal subclass of &lt;code&gt;NSString&lt;/code&gt; for file pathnames - which matched the selector &lt;code&gt;-isAbsolutePath&lt;/code&gt; and matched the call site's expectations. The theory that the object pointer was valid looked good.
    &lt;p&gt;
      The object pointer was good, and the method cache was not: the failure was on the chain between them. The contents of the object looked good. The bytes looked like alternating zero and ASCII, which is a dead giveaway for the UTF-16 used inside &lt;code&gt;NSString&lt;/code&gt;. The string value decoded as &lt;code&gt;@"/Xcode4/usr/bin/llvm-gcc"&lt;/code&gt;, which made sense in the call site's context.
    &lt;p&gt;
      The object's &lt;code&gt;isa&lt;/code&gt; pointer was not so good. Its value was &lt;code&gt;0xa0050000&lt;/code&gt;. This was not class &lt;code&gt;NSPathStore2&lt;/code&gt; or any other class. &lt;code&gt;vmmap&lt;/code&gt; showed it to be in Foundation's data segment, and &lt;code&gt;otool&lt;/code&gt; showed it was specifically in Foundation's constant CF strings. But instead of pointing to the start of some string, it pointed to the middle of a string object. That string object was &lt;code&gt;@"tzm-Latn"&lt;/code&gt;: some localization thingy, perhaps? Theory: some bug had replaced this object's isa pointer with a pointer to the middle of an unrelated localization string object. This did not sound like a good theory.
    &lt;p&gt;
      Go back to the board. Symptom: the object was allocated as an &lt;code&gt;NSPathStore2&lt;/code&gt;. Symptom: the object's &lt;code&gt;isa&lt;/code&gt; pointer is now &lt;code&gt;0xa0050000&lt;/code&gt;, which is not &lt;code&gt;NSPathStore2&lt;/code&gt;. What should the &lt;code&gt;isa&lt;/code&gt; pointer's value have been? &lt;code&gt;otool&lt;/code&gt; and &lt;code&gt;objc_getClass()&lt;/code&gt; agreed: the correct &lt;code&gt;isa&lt;/code&gt; pointer should have been &lt;code&gt;0xa005f198&lt;/code&gt;. &lt;code&gt;0xa0050000&lt;/code&gt; is suspiciously similar. Theory: something had cleared two bytes of this object, leaving a nonsense &lt;code&gt;isa&lt;/code&gt; pointer. &lt;code&gt;@"tzm-Latn"&lt;/code&gt; was a red herring.
    &lt;p&gt;
      Aha! This is 32-bit i386. Little endian. The pointer &lt;code&gt;0xa005f198&lt;/code&gt; is stored backwards in memory: &lt;code&gt;0x98 0xf1 0x05 0xa0&lt;/code&gt;. Clearing the least-significant bytes of the &lt;code&gt;isa&lt;/code&gt; pointer meant clearing bytes 0 and 1 of the object, not bytes 2 and 3. Damage to bytes 0 and 1 is exactly what you'd expect from a two-byte overrun of the object preceding this one in memory. Theory: the bug was in that preceding object, and this &lt;code&gt;NSPathStore2&lt;/code&gt; object was an innocent victim.
    &lt;p&gt;
      &lt;code&gt;malloc_history&lt;/code&gt; works with a pointer to the middle of an allocation, too. We plugged in &lt;code&gt;object-1&lt;/code&gt; and got back an instance of &lt;code&gt;DVTSourceModelItem&lt;/code&gt;, not deallocated. Rick recognized this as part of Xcode's indexer, which was always running in another thread at the time of the crash. A buffer overrun from the &lt;code&gt;DVTSourceModelItem&lt;/code&gt; object fit the symptoms.
    &lt;p&gt;
      But where was the buffer? I had expected an overrun in some heap-allocated C array, not an ordinary object. Nor did &lt;code&gt;DVTSourceModelItem&lt;/code&gt; have any C arrays in its instance variables. 
    &lt;p&gt;
      Theory: the compiler or runtime had allocated too little memory for the instance of class &lt;code&gt;DVTSourceModelItem&lt;/code&gt;, and ordinary ivar access had overrun that allocation. It was a long shot, but easy to test. &lt;code&gt;malloc_size()&lt;/code&gt; and &lt;code&gt;class_getInstanceSize()&lt;/code&gt; and an eyeball count of ivars all agreed that the object was 32 bytes. Theory disproved.
    &lt;p&gt;
      We tested the overrun theory again. Add an unused ivar to the end of &lt;code&gt;DVTSourceModelItem&lt;/code&gt;, recompile, and run it. No crash. Remove the ivar. Crash. The extra ivar "fixed" the bug. The buffer overrun theory still fit the evidence, but we couldn't find it. 
    &lt;p&gt;
      No more ideas. We needed data. Debugger watchpoints were out: there were thousands of instances of &lt;code&gt;DVTSourceModelItem&lt;/code&gt;, and we couldn't watch two bytes after each of them. We were not yet desperate enough to try brute force code inspection. &lt;code&gt;AUTO_USE_GUARDS=YES&lt;/code&gt; could catch it, if it didn't fall over first. Since we had a suspect in mind, we could play the &lt;code&gt;guardmalloc&lt;/code&gt; trick ourselves with a narrower target. Override &lt;code&gt;+[DVTSourceModelItem alloc]&lt;/code&gt;, &lt;code&gt;mprotect()&lt;/code&gt; the page after the allocation, and cross our fingers really hard hoping that it still reproduced after changing the timing so much.
    &lt;p&gt;
      Bang! It crashed (good) somewhere new (also good). &lt;code&gt;DVTSourceModelItem&lt;/code&gt; &lt;code&gt;-init&lt;/code&gt; was writing to one of its own instance variables. The ivar was a bit in a bitfield, and that bitfield was at the end of the ivar list. 
    &lt;p&gt;
      Disassemble. The generated code read 4 bytes around the bit into a register, change the bit in that register, and wrote the 4 bytes back to memory. That's typical for a bitfield. The unexpected part was that the 4 bytes spanned the last two bytes of the object and the first two bytes after the object. That's a bug. Most of the time the out of bounds access is invalid - it reads two bytes it shouldn't, and writes back the same value. But if there's another thread it can crash:
      &lt;table border=1 cellspacing=0 cellpadding=4&gt;
	&lt;tr&gt;&lt;td align=center&gt;Thread 1&lt;/td&gt;&lt;td align=center&gt;Thread 2&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;reads four bytes, including two&lt;br&gt;bytes outside the object&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;allocates a new object&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;writes an isa pointer&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;writes four bytes, clobbering the&lt;br&gt;new value written by Thread 2&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;crashes&lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;
    &lt;p&gt;
      Theory: a compiler bug generated bad code for &lt;code&gt;DVTSourceModelItem&lt;/code&gt;'s bitfield ivar, causing a read-modify-write out of bounds by two bytes, which corrupted memory in other threads. Test: try a different compiler. &lt;code&gt;DVTSourceModelItem.m&lt;/code&gt; was built with &lt;code&gt;clang&lt;/code&gt;, so we recompiled with &lt;code&gt;llvm-gcc&lt;/code&gt;. No crash, and the disassembly looked correct. Compile with &lt;code&gt;clang&lt;/code&gt; again, crash again.
    &lt;p&gt;
      Diagnosis: &lt;code&gt;clang&lt;/code&gt; compiler bug in bitfield ivars. The patient's symptoms were treated with an extra ivar in &lt;code&gt;DVTSourceModelItem&lt;/code&gt; until a compiler transplant could be performed. 
    &lt;p&gt;
      Elapsed time: about three hours. Too long for an episode of a TV procedural drama, unfortunately. 
    &lt;/p&gt;
</description>
    </item>
    <item>
      <title>TargetConditionals.h</title>
      <link>http://www.sealiesoftware.com/blog/archive/2010/8/16/TargetConditionalsh.html</link>
      <pubDate>16 Aug 2010 14:30 PDT</pubDate>
      <description>    &lt;p&gt;
    Updated 2017-2-27
    &lt;p&gt;
    &lt;table border=1 cellspacing=0 cellpadding=4&gt;
      &lt;th&gt;&lt;td align=center&gt;macOS&lt;/td&gt;&lt;td align=center&gt;iOS device&lt;/td&gt;&lt;td align=center&gt;iOS simulator&lt;/td&gt;&lt;td align=center&gt;tvOS device&lt;/td&gt;&lt;td align=center&gt;tvOS simulator&lt;/td&gt;&lt;/th&gt;&lt;td align=center&gt;watchOS device&lt;/td&gt;&lt;td align=center&gt;watchOS simulator&lt;/td&gt;&lt;/th&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_OSX&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_IOS&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_TV&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_WATCH&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_SIMULATOR&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td colspan=8&gt;&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_MAC&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_IPHONE&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_OS_EMBEDDED&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td bgcolor=#eeffee&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;TARGET_IPHONE_SIMULATOR&lt;/td&gt;&lt;td colspan=7&gt;same as TARGET_OS_SIMULATOR&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;br&gt;
</description>
    </item>
    <item>
      <title>Do-it-yourself Objective-C weak import</title>
      <link>http://www.sealiesoftware.com/blog/archive/2010/4/8/Do-it-yourself_Objective-C_weak_import.html</link>
      <pubDate>8 Apr 2010 22:23 PDT</pubDate>
      <description>      &lt;h4&gt;WARNING  DANGER  HAZARD  BEWARE  EEK&lt;/h4&gt;
      &lt;p&gt;
	The scheme described herein is &lt;b&gt;UNTESTED&lt;/b&gt; and probably
	&lt;b&gt;BUGGY&lt;/b&gt;. Use at your own risk.  
      &lt;/p&gt;
      &lt;h4&gt;Executive summary&lt;/h4&gt;
      &lt;p&gt;
	The Objective-C runtime supports &lt;a href="http://sealiesoftware.com/blog/archive/2009/09/09/objc_explain_Weak-import_classes.html"&gt;weak-imported classes&lt;/a&gt; back to
	iPhone OS 3.1. An app could use a class added in iPhone OS 3.2 or
	4.0 and still run on 3.1. The app would check if &lt;code&gt;[SomeClass
	class]&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; and act accordingly.
      &lt;/p&gt;
      &lt;p&gt;
	Unfortunately, the compilers and class declarations in framework
	headers do not support weak import yet. But you may be able to use
	weak linking anyway, by adding the right incantations yourself.
      &lt;/p&gt;
      &lt;p&gt;
	To &lt;b&gt;use&lt;/b&gt; a class &lt;code&gt;SomeClass&lt;/code&gt; that is unavailable
	on some of your app's deployment targets, write this in
	&lt;b&gt;every&lt;/b&gt; file that uses the class:&lt;pre&gt;
    asm(".weak_reference _OBJC_CLASS_$_SomeClass");&lt;/pre&gt;
	To &lt;b&gt;subclass&lt;/b&gt; a class &lt;code&gt;SomeClass&lt;/code&gt; that is unavailable 
	on some of your app's deployment targets, write this in 
	the file containing your subclass's
	&lt;code&gt;@implementation&lt;/code&gt;:&lt;pre&gt;
    asm(".weak_reference _OBJC_CLASS_$_SomeClass");
    asm(".weak_reference _OBJC_METACLASS_$_SomeClass");&lt;/pre&gt;
	This will not work for apps running on iPhone OS 3.0 or
	older. Only iPhone OS 3.1 and newer has any hope of success. Of
	course, since this is &lt;b&gt;UNTESTED&lt;/b&gt; it may not work there either.
      &lt;/p&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;
	Say you're writing a game, and want to use the hypothetical
	&lt;code&gt;UIDancePad&lt;/code&gt; class added to iPhone OS 3.2. (Do not
	dance on iPad.) When you use class &lt;code&gt;UIDancePad&lt;/code&gt; in your
	code, the compiler emits a C symbol pointing to the class:&lt;pre&gt;
    .long _OBJC_CLASS_$_UIDancePad&lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;
	Since &lt;code&gt;UIDancePad&lt;/code&gt; is in a framework instead of your
	code, the symbol remains undefined in your executable, as shown by
	&lt;code&gt;`nm -m`&lt;/code&gt;:&lt;pre&gt;
    (undefined) external _OBJC_CLASS_$_UIDancePad (from DanceKit)&lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;
	When you run on iPhone OS 3.2, everything works great: the dynamic
	loader opens your executable and DanceKit, and binds your
	undefined symbol to their class definition.
      &lt;/p&gt;
      &lt;p&gt;
	Things don't go so well on iPhone OS 3.1. DanceKit exists but does
	not define &lt;code&gt;UIDancePad&lt;/code&gt;. The dynamic loader is unable
	to resolve 
	your undefined symbol, and the process halts:&lt;pre&gt;
    dyld: Symbol not found: _OBJC_CLASS_$_UIDancePad
        Referenced from: /path/to/YourApp
        Expected in: /path/to/DanceKit&lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;
	Weak import solves this. The compiled symbol reference is now a
	weak one:&lt;pre&gt;
    .weak_reference _OBJC_CLASS_$_UIDancePad
    .long _OBJC_CLASS_$_UIDancePad

    (undefined) weak external _OBJC_CLASS_$_UIDancePad (from DanceKit)&lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;
	The dynamic loader shrugs its shoulders if a weak reference cannot
	be resolved, and sets the pointer to &lt;code&gt;NULL&lt;/code&gt;. The
	Objective-C runtime sees the &lt;code&gt;NULL&lt;/code&gt; pointer and fixes
	up the rest of the metadata as if &lt;code&gt;UIDancePad&lt;/code&gt; never
	existed. 
      &lt;/p&gt;
      &lt;p&gt;
	As mentioned above, the compiler and framework header support is
	not yet in place. The incantations simply add the
	assembler directives that the compiler does not yet know how to
	emit:&lt;pre&gt;
    asm(".weak_reference _OBJC_CLASS_$_UIDancePad");&lt;/pre&gt;
      &lt;/p&gt;
      &lt;p&gt;
	Et voil&amp;agrave;: weak import of an Objective-C class. Well, maybe. I have
	only tested this on toy examples, none of which got anywhere close
	to any version of iPhone OS. Coder beware!
      &lt;/p&gt;
      &lt;p&gt;
	(What about the &lt;code&gt;_OBJC_METACLASS&lt;/code&gt; symbol, you ask? When
	you subclass a class, your subclass's
	metaclass's superclass pointer points to the subclass's superclass's
	metaclass. In other words, your subclass's
	&lt;code&gt;@implementation&lt;/code&gt; points to both its superclass and its
	superclass's &lt;a
	href="http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html"&gt;metaclass&lt;/a&gt;. That
	requires two symbols: one for the class and one for the
	metaclass. When you simply use a class without subclassing it, you
	don't need the metaclass pointer.)
      &lt;/p&gt;
</description>
    </item>
    <item>
      <title>[objc explain]: Weak-import classes</title>
      <link>http://www.sealiesoftware.com/blog/archive/2009/09/09/objc_explain_Weak-import_classes.html</link>
      <pubDate>09 Sep 2009 13:30 PDT</pubDate>
      <description>      &lt;p&gt;
	Weak-import classes are a useful new Objective-C feature that you
	can't use yet. 
      &lt;/p&gt;
      &lt;p&gt;
	Weak import is a solution when you want to use something from a
	framework, but still need to be compatible with older versions of
	the framework that didn't support it yet. Using weak import you
	can test if the feature exists at runtime before you try to use
	it. 
      &lt;/p&gt;
      &lt;p&gt;
	Objective-C has not previously supported weak import for
	classes. Instead you had to use clumsy runtime introspection to
	check whether a class was available, store a pointer to that class
	in a variable, and use that variable when you wanted to send a
	message to the class. Even worse, there was no reasonable way to
	create your own subclass of a superclass that might be
	unavailable. Some developers put the subclass in a separate
	library that was not loaded until after checking that the
	superclass was present, but even that trick is not allowed on
	iPhone OS. 
      &lt;/p&gt;
      &lt;p&gt;
	Weak import for C functions works by checking the weak-imported
	function pointer's value before calling it:
      &lt;/p&gt;
      &lt;pre&gt;    if (NSNewFunction != NULL) {
        NSNewFunction(...);
    } else {
        // NSNewFunction not supported on this system
    }&lt;/pre&gt;
      &lt;p&gt;
	The same mechanism is a natural fit with Objective-C classes and 
	Objective-C's handling of messages to nil. These constructs are
	much nicer than &lt;code&gt;NSClassFromString()&lt;/code&gt; or a separate 
	&lt;code&gt;NSBundle&lt;/code&gt;. 
      &lt;/p&gt;
      &lt;pre&gt;    if ([NSNewClass class] != nil) {
        [NSNewClass doSomething];
    } else {
        // NSNewClass is unavailable on this system
    }&lt;/pre&gt;
      &lt;pre&gt;    @interface MySubclass : NSNewClass ... @end
    MySubclass *obj = [[MySubclass alloc] init];
    if (!obj) {
        // MySubclass (or a superclass thereof) is unavailable on this system
    }&lt;/pre&gt;
      &lt;p&gt;
	Weak import of Objective-C classes is now available. But you can't
	use it yet. First, it's only supported today on iPhone OS 3.1; 
	it's expected to arrive in a future Mac OS. 
      &lt;/p&gt;
      &lt;p&gt;
	Second, there's nothing you can do with weak import until the
	first OS update &lt;i&gt;after&lt;/i&gt; iPhone OS 3.1. Then you could write an app
	that adopted new features in that future version, and used weak import
	to be compatible with 3.1. (It still could not run on 3.0 or 2.x,
	because those systems lack the runtime machinery to process the
	weak import references.)
      &lt;/p&gt;
      &lt;p&gt;
	Weak import for Objective-C did not make Snow Leopard for
	scheduling reasons. Assuming it ships in Mac OS X 10.7 Cat Name
	Forthcoming, you won't be able to use it until Mac OS X 10.8
	LOLcat. 
      &lt;/p&gt;
</description>
    </item>
    <item>
      <title>Colorized keyboard backlight</title>
      <link>http://www.sealiesoftware.com/blog/archive/2009/09/05/Colorized_keyboard_backlight.html</link>
      <pubDate>05 Sep 2009 1:15 PDT</pubDate>
      <description>    &lt;p&gt;
      I use my MacBook Pro for astronomy. The backlit keyboard would be
      great in the dark, but its white light is bad for night
      vision. &lt;a href="/keyboard/index.html"&gt;This mod&lt;/a&gt; makes it red, or any other color you want.
    &lt;/p&gt;
</description>
    </item>
  </channel>
</rss>
