<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Values and errors, part 1: &#39;Result&#39; in Swift</title>
  <meta name="description" content="In this article, I&#39;ll discuss the `Result` type in Swift as well as common variations in implementation and approach used for this data type. I&#39;ll also look at *why* the type was rejected for inclusion in the standard library and what effect that rejection is likely to have." />

  <meta name="twitter:title" content="Values and errors, part 1: &#39;Result&#39; in Swift"/>
  <meta name="twitter:image" content="https://www.cocoawithlove.com/assets/site/touch_heartandcup.png"/>
  <meta name="twitter:url" content="https://www.cocoawithlove.com/blog/2016/08/21/result-types-part-one.html"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:description" content="In this article, I&#39;ll discuss the `Result` type in Swift as well as common variations in implementation and approach used for this data type. I&#39;ll also look at *why* the type was rejected for inclusion in the standard library and what effect that rejection is likely to have."/>

  <link rel="icon" href="../../../../assets/site/heartandcup.png" />
  <link rel="apple-touch-icon" href="../../../../assets/site/touch_heartandcup.png" />
  <link rel="stylesheet" href="../../../../css/main.css" />
  <link rel="canonical" href="result-types-part-one.html" />

  
</head>

<body>

<div class="hidetopextension"></div>
<header class="nav-header">
  <div class="wrapper">
  	<a href="../../../../index.html"><img class="heartandcup" src="../../../../assets/site/heartandcup.svg"></a>
  	<a class="top" href="#">top</a>
    <nav class="site-nav" onClick="if (this.className == 'site-nav') { this.className = 'site-nav-collapsed'; } else { this.className = 'site-nav'; }">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="../../../../about/index.html">about</a>
        <a class="page-link" href="../../../../archive/index.html">archive</a>
        <a class="page-link" href="../../../../search/index.html">search</a>
        <a class="page-link" href="http://zqueue.com/">zqueue.com</a>
      </div>
    </nav>
  </div>
</header>

<div class="nav-header-baseline"></div>

<div class="wrapper"><div class="hidetop"></div></div>

<header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="../../../../index.html">
      <img class="site-banner" alt="Matt Gallagher: Cocoa with Love" src="../../../../assets/site/banner.svg" width="720px" height="135px">
    </a>
  </div>
</header>

<div class="banner-baseline"></div>

<div class="page-content">
<div class="wrapper">


<header class="post-header">
	<h1 class="post-title" itemprop="headline">Values and errors, part 1: &#39;Result&#39; in Swift</h1>
	<div class="post-meta"><time itemprop="datePublished" datetime="2016-08-21">August 21, 2016</time> by Matt Gallagher</div>
	<div class="post-tags">Tags:
		
			<a href="../../../../tags/swift.html">Swift</a>, <a href="../../../../tags/fundamentals.html">fundamentals</a>, <a href="../../../../tags/error-handling.html">error handling</a>
		 
	</div>
</header>


<main role="main">
	<article itemscope itemtype="http://schema.org/BlogPosting">
		<div class="post-content" itemprop="articleBody">
			

<p>Swift&rsquo;s error handling has a major limitation: it can only be used to pass an error to an enclosing <code>catch</code> scope or the previous function on the stack.</p>

<p>If you want to handle errors across asynchronous boundaries or store value/error results for later processing, then Swift error handling won&rsquo;t help. The best alternative is a common pattern called a <code>Result</code> type: it stores a value/error &ldquo;sum&rdquo; type (either one <em>or</em> the other) and can be used between any two arbitrary execution contexts.</p>

<p>It&rsquo;s an incredibly simple type but since the handling of value/error results sits a critical position in many types of operation, it provides an interesting look into the capabilities and priorities of a programming language. The <code>Result</code> type is so useful that it was <em>almost</em> included in the Swift standard library and even its <em>rejection</em> reveals an interesting look at the philosophies underpinning Swift&rsquo;s design.</p>

<p>In this article, I&rsquo;ll discuss the <code>Result</code> type in Swift as well as common variations in implementation and approach used for this data type. I&rsquo;ll also look at <em>why</em> the type was rejected for inclusion in the standard library and what effect that rejection is likely to have.</p>

<nav id="TableOfContents"><span class="toc-heading">Contents</span>
<ul>
<li>
<ul>
<li><a href="#a-tagged-union-of-success-and-failure">A tagged union of success and failure</a></li>
<li><a href="#the-result-type">The <code>Result</code> type</a></li>
<li><a href="#a-result-example">A <code>Result</code> example</a></li>
<li><a href="#using-result-as-a-monad">Using <code>Result</code> as a monad</a></li>
<li><a href="#specifying-an-error-parameter">Specifying an error parameter</a></li>
<li><a href="#comparing-result-and-swift-error-handling">Comparing <code>Result</code> and Swift error handling</a></li>
<li><a href="#in-the-standard-library">In the standard library</a></li>
<li><a href="#implications-of-no-result-type-in-the-standard-library">Implications of no <code>Result</code> type in the standard library</a></li>
<li><a href="#conclusion-and-usage">Conclusion and usage</a>
<ul>
<li><a href="#looking-forward">Looking forward</a></li>
</ul></li>
<li><a href="#aside-1-why-then-does-the-standard-library-include-optional">Aside 1: Why then does the standard library include <code>Optional</code>?</a></li>
<li><a href="#aside-2-either-types">Aside 2: <code>Either</code> types</a></li>
</ul></li>
</ul>
</nav>

<h2 id="a-tagged-union-of-success-and-failure">A tagged union of success and failure</h2>

<p>I&rsquo;ve <a href="../../03/17/non-pure-errors.html#impact-of-a-composite-type-on-the-caller">previously talked about how errors</a> are inherently &ldquo;composite&rdquo;: they represent a combination of multiple data paths or potential data values that are brought together to produce a single result that reflects the path taken and the state encountered. Within a larger operation, the results from multiple steps are composed to produce the final output.</p>

<p>If you&rsquo;re familiar with Swift, then you know that Swift&rsquo;s inbuilt error handling deals with the different paths associated with &ldquo;success&rdquo; and &ldquo;failure&rdquo; states by decorating functions with the <code>throws</code> keyword which allows them to have two separate exit paths: a <code>return</code> path for the normal value and a <code>throws</code> path for an <code>Error</code> type.</p>

<p>I&rsquo;m sure you already know what Swift error handling looks like but here&rsquo;s an example so I can refer back to it later:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// A simple function that returns the time since boot, if it is even</span>
<span class="c1">// otherwise throws an error</span>
<span class="kd">func</span> <span class="nf">evenTimeValue</span><span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">UInt64</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">mach_absolute_time</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">case</span> <span class="kd">let</span> <span class="nv">t</span> <span class="k">where</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span>
   <span class="k">default</span><span class="p">:</span> <span class="k">throw</span> <span class="n">TimeError</span><span class="p">.</span><span class="n">expectedEvenGotOdd</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">TimeError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{</span> <span class="k">case</span> <span class="n">expectedEvenGotOdd</span> <span class="p">}</span>

<span class="c1">// Calling the function and handling the error</span>
<span class="k">do</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="k">try</span> <span class="n">evenTimeValue</span><span class="p">())</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>The <code>evenTimeValue</code> result may return a <code>UInt64</code> or it may throw a <code>TimeError.expectedEvenGotOdd</code> error. This composite result is immediately decomposed in the <code>do</code> block by splitting into two paths, the <code>print(try evenTimeValue())</code> path and the <code>print(error)</code> path.</p>

<h2 id="the-result-type">The <code>Result</code> type</h2>

<p>Swift&rsquo;s error handling works to return value/error results to callers on the stack but it won&rsquo;t pass value/error results in any other way. Examples of scenarios you might want to handle where Swift&rsquo;s error handling won&rsquo;t help include:</p>

<ul>
<li>results passed between threads</li>
<li>results asynchronously delivered to the current thread</li>
<li>results retained for any duration</li>
<li>results passed into a function rather than out of a function.</li>
</ul>

<p>Many of these alternate scenarios fall under the banner of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">&ldquo;continuation passing style&rdquo;</a> (a design pattern where, instead of directly returning a result, functions invoke a provided &ldquo;handler&rdquo; function and pass the result into it). Work with Swift for long enough and you&rsquo;re likely to use a continuation passing style eventually. Depending on the nature of your work, you might even need to store errors and other results.</p>

<p>The obvious candidate in these other scenarios is a <code>Result</code> type. Where Swift&rsquo;s error handling encapsulates the composite nature of error handling by using &ldquo;value&rdquo; and &ldquo;error&rdquo; return paths from a function, a <code>Result</code> type embeds the &ldquo;value&rdquo; or &ldquo;error&rdquo; directly into a composite data type:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Result</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">success</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">failure</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>Most <code>Result</code> implementations also offer <code>map</code> and <code>flatMap</code> methods, conversion to an optional value/error and conversion to/from a Swift <code>throws</code> function.</p>

<p>That&rsquo;s about it; it&rsquo;s a type that is better served by a narrow implementation.</p>

<h2 id="a-result-example">A <code>Result</code> example</h2>

<p>Imagine our <code>evenTime()</code> function was computationally intensive and we wanted to invoke it outside the main queue. We might then need a callback function to report the result:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// A version of `evenTimeValue` that returns a `Result` instead of throwing</span>
<span class="kd">func</span> <span class="nf">evenTimeValue</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">&lt;</span><span class="nb">UInt64</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">mach_absolute_time</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">case</span> <span class="kd">let</span> <span class="nv">t</span> <span class="k">where</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
   <span class="k">default</span><span class="p">:</span> <span class="k">return</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="n">TimeError</span><span class="p">.</span><span class="n">expectedEvenGotOdd</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// An async wrapper around `evenTime` that invokes a callback when complete</span>
<span class="kd">func</span> <span class="nf">asyncEvenTime</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="nb">UInt64</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">().</span><span class="n">async</span> <span class="p">{</span> <span class="n">callback</span><span class="p">(</span><span class="n">evenTimeValue</span><span class="p">())</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This is equivalent to the do/catch block labelled &#34;Calling the</span>
<span class="c1">// function and handling the error&#34; in the previous example</span>
<span class="n">asyncEvenTime</span> <span class="p">{</span> <span class="n">timeResult</span> <span class="k">in</span>
   <span class="k">switch</span> <span class="n">timeResult</span> <span class="p">{</span>
   <span class="k">case</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="kd">let</span> <span class="nv">value</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
   <span class="k">case</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="kd">let</span> <span class="nv">error</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>As in the Swift error handling example, the <code>asyncEvenTime</code> function may generate a <code>UInt64</code> or it may generate a <code>TimeError.expectedEvenGotOdd</code> error but in this case, the value or error is wrapped in a <code>.success</code> or <code>.failure</code> case of the <code>Result&lt;UInt64&gt;</code> and passed into the <code>callback</code> function. This <code>enum</code> is manually unwrapped and pattern matched by the <code>switch</code> statement, splitting into two paths, the <code>print(value)</code> path and the <code>print(error)</code> path.</p>

<p>Without language integration, the compiler doesn&rsquo;t <em>force</em> us to handle the <code>timeResult</code>. Otherwise, the effect is very similar: <code>Result</code> handling and Swift error handling process the same data flow in very similar ways.</p>

<h2 id="using-result-as-a-monad">Using <code>Result</code> as a monad</h2>

<p>Some people view a <code>Result</code> type as a functional programming construct that should be manipulated using <code>flatMap</code> calls. The <code>flatMap</code> function looks like this:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">Result</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">flatMap</span><span class="p">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">Value</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="kd">let</span> <span class="nv">val</span><span class="p">):</span> <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="kd">let</span> <span class="nv">e</span><span class="p">):</span> <span class="k">return</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>The intent of <code>flatMap</code> is to <em>avoid</em> unwrapping the <code>Result</code> in your own code. Instead, you let the <code>flatMap</code> unwrap the <code>Result</code> and <em>if</em> it happens to contain a <code>.success</code>, the <code>flatMap</code> function will invoke your code to process the <code>.success</code> value appropriately and pass it to the next stage in the processing pipeline, otherwise the <code>flatMap</code> function will short-circuit passed your processing function and instead pass the existing <code>.failure</code> error along to the next stage in the processing pipeline.</p>

<p>Types manipulated exclusively with <code>flatMap</code> (or functions implemented on top of <code>flatMap</code>) are called &ldquo;monads&rdquo;. By never accessing the contents directly and instead interacting through the &ldquo;black box&rdquo; of the <code>flatMap</code> function, your program avoids being dependent on the state of the value inside the monad. Since avoiding dependency on state is a key aim of functional programming, monads end up being a key pattern in functional programming.</p>

<p>It&rsquo;s important to note though that Swift is <em>not</em> a functional programming language and <em>I didn&rsquo;t use</em> <code>flatMap</code> in the <code>asyncEvenTime</code> example. The <code>Result</code> type was merely used as data transport with any logic applied either before wrapping the <code>Result</code> or after unwrapping at the end.</p>

<p>There are certainly situations where you might choose to use <code>Result</code> as a monad (I show an example in the <a href="#comparing-result-and-swift-error-handling">Comparing Result and Swift error handling</a> section, below) but any such usage is not required. I personally think it&rsquo;s appropriate to consider unwrapping with a <code>switch</code> statement as a <em>first</em> option and consider more abstract functional operators as a <em>second</em> option, only when they constitute a clear simplification.</p>

<h2 id="specifying-an-error-parameter">Specifying an error parameter</h2>

<p>Some implementations of <code>Result</code> use a generic parameter for the error:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Result</span><span class="p">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">success</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">failure</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>There are some problems though with strongly typing errors like this in Swift. On the Swift Evolution mailing list, <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001450.html">John McCall offers some comments on the subject</a>.</p>

<p>Basically, this approach would be fine if we could define a type as:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">result</span><span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">FileError</span> <span class="o">|</span> <span class="n">NetworkError</span><span class="o">&gt;</span></code></pre></div>

<p>where the error is a &ldquo;structural sum type&rdquo; (a type that is either <code>FileError</code> or <code>NetworkError</code>) but we can&rsquo;t do this in Swift at the moment.</p>

<p>Instead, we would need to manually define an enum each time:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">ErrorFromMyFunction</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">file</span><span class="p">(</span><span class="n">FileError</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">network</span><span class="p">(</span><span class="n">NetworkError</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>That might not seem too bad but this then requires we manually wrap and unwrap error types as they occur inside our interface to get them into the correct container <code>enum</code>, since a manually constructed <code>enum</code> can&rsquo;t be constructed from an unrelated error <code>enum</code> using <code>flatMap</code> or other composing functions.</p>

<p>Frankly, until Swift supports structural sum types (and there is no guarantee that it ever will), this can potentially involve a lot of manual work propagating errors to communicate a small amount of additional type information that the interface user will promptly ignore by treating all errors identically (bail out on any error).</p>

<h2 id="comparing-result-and-swift-error-handling">Comparing <code>Result</code> and Swift error handling</h2>

<p>I&rsquo;ve shown how you can use a <code>Result</code> for asynchronous callbacks but it&rsquo;s worth considering how a <code>Result</code> would compare to Swift&rsquo;s error handling if they were both used in the same &ldquo;function return&rdquo; scenario.</p>

<p>Consider a function that invokes the previous <code>evenTimeValue</code> function and adds a previously obtained <code>UInt64</code> value:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// Using Swift error handling:</span>
<span class="kd">func</span> <span class="nf">addToEvenTime</span><span class="p">(</span><span class="kc">_</span> <span class="n">previous</span><span class="p">:</span> <span class="nb">UInt64</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">UInt64</span> <span class="p">{</span>
   <span class="k">return</span> <span class="k">try</span> <span class="n">previous</span> <span class="o">+</span> <span class="n">evenTimeValue</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Using a `Result` return type:</span>
<span class="kd">func</span> <span class="nf">addToEvenTime</span><span class="p">(</span><span class="kc">_</span> <span class="n">previous</span><span class="p">:</span> <span class="nb">UInt64</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">&lt;</span><span class="nb">UInt64</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">evenTimeValue</span><span class="p">().</span><span class="bp">map</span> <span class="p">{</span> <span class="n">previous</span> <span class="o">+</span> <span class="nv">$0</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>I&rsquo;m using <code>map</code> in the <code>Result</code> implementation to avoid unwrapping and rewrapping (<code>map</code> is a <code>flatMap</code> where the output from <code>transform</code> is always wrapped in a <code>.success</code>). Meanwhile, Swift&rsquo;s error handling doesn&rsquo;t require handling of wrapped values.</p>

<p>Now, let&rsquo;s look at how Swift error handling and <code>Result</code> handling compare when chaining three calls to <code>addToEvenTime</code> together:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// Using Swift error handling:</span>
<span class="kd">func</span> <span class="nf">sumOfThreeEvenTimes</span><span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">UInt64</span> <span class="p">{</span>
   <span class="k">return</span> <span class="k">try</span> <span class="n">addToEvenTime</span><span class="p">(</span><span class="n">addToEvenTime</span><span class="p">(</span><span class="n">addToEvenTime</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c1">// Using a `Result` return type:</span>
<span class="kd">func</span> <span class="nf">sumOfThreeEvenTimes</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">&lt;</span><span class="nb">UInt64</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">addToEvenTime</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">flatMap</span><span class="p">(</span><span class="n">addToEvenTime</span><span class="p">).</span><span class="n">flatMap</span><span class="p">(</span><span class="n">addToEvenTime</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>The comparison between these two approaches provides a good insight into Swift&rsquo;s design philosophy. The <em>effect</em> of Swift&rsquo;s error handling over successive <code>throws</code> statements is equivalent to the monadic <code>flatMap</code> over multiple <code>Result</code> generating functions but Swift avoids making abstract mathematical concepts like <code>map</code> and <code>flatMap</code> a required part of the core language and instead makes the code <em>look</em> as though it is a simple, linear sequence of actions.</p>

<p>As a counterpoint, <code>Result</code> is not really much more complicated, despite lacking any language integration. If you find a situation where Swift&rsquo;s error handling is not practical, then switching to <code>Result</code> instead is relatively simple. If you use asynchronous workflows and other data-flow scenarios, then you might find <code>Result</code> is pratically required.</p>

<h2 id="in-the-standard-library">In the standard library</h2>

<p>Multiple people have suggested, via the Swift Evolution mailing list, that the Swift standard library should incorporate <code>Result</code>. At one point in time, the Swift development team themselves suggested a <code>Result</code> type might be added to the standard library to handle cases that Swift&rsquo;s built-in error handling couldn&rsquo;t cover (see <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst#manual-propagation-and-manipulation-of-errors">ErrorHandling.rst</a> in the docs directory of the Swift repository).</p>

<p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001433.html">John McCall explains the Swift standard library team&rsquo;s verdict as follows</a>:</p>

<blockquote>
<p>We considered it, had some specifics worked out, and then decided to put it on hold.  Part of our reasoning was that it seemed more like an implementation detail of the async / CPS-conversion features we’d like to provide than an independently valuable feature, given that we don’t want to encourage people to write library interfaces using functional-style error handling instead of throws.</p>
</blockquote>

<p>Ultimately, while a <code>Result</code> type <em>is</em> useful in Swift, the Swift team would rather avoid directly endorsing alternatives to <code>throws</code> approach since it is not their first preference and they ultimately hope to extend the <code>throws</code> style handling to other scenarios.</p>

<p>The &ldquo;async / CPS-conversion features&rdquo; hinted at are the potential future <a href="../../06/02/threads-and-mutexes.html#future-concurrency-in-swift">Swift &ldquo;Concurrency&rdquo; features that I&rsquo;ve mentioned previously</a>. Sadly though, no features will be delivered in this area <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html">until after Swift 4</a>.</p>

<h2 id="implications-of-no-result-type-in-the-standard-library">Implications of no <code>Result</code> type in the standard library</h2>

<p>What are the implications of omitting a type from a standard library?</p>

<p>If a commonly used type is neither part of the standard library nor sourced from a single common repository, this results in two common problems:</p>

<ol>
<li>Bloated code size due to replication</li>
<li>Interoperability between multiple independent implementations</li>
</ol>

<p>Since a <code>Result</code> type is mostly just an <code>enum</code> definition, it may add some runtime type information to the executable but it won&rsquo;t add to the actual code size. Methods that operate on the <code>Result</code> type do have measurable size but the most complicated extension you&rsquo;re likely to need, <code>flatMap</code>, is just five lines. Even with a broad range of helper functions, a <code>Result</code> implementation should be less than 100 lines. It certainly isn&rsquo;t a big code overhead on your project.</p>

<p>Interoperability between multiple independent implementations is a bigger concern but again, unlikely to become a major headache. The biggest reason for this is that any two implementations will always have a path through which they can be converted: Swift&rsquo;s <code>throws</code> error handling.</p>

<p>Provided any two implementations contain the following two functions:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">Result</span> <span class="p">{</span>
   <span class="c1">// Construct a `Result` from a Swift `throws` error handling function</span>
   <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">capturing</span><span class="p">:</span> <span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="p">{</span>
         <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="k">try</span> <span class="n">capturing</span><span class="p">())</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
         <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">// Convert the `Result` back to typical Swift `throws` error handling</span>
   <span class="kd">public</span> <span class="kd">func</span> <span class="nf">unwrap</span><span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Value</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="kd">let</span> <span class="nv">v</span><span class="p">):</span> <span class="k">return</span> <span class="n">v</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="kd">let</span> <span class="nv">e</span><span class="p">):</span> <span class="k">throw</span> <span class="n">e</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>then any two different definitions of <code>Result</code> from different modules could be converted as follows:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">firstResult</span><span class="p">:</span> <span class="n">Module1</span><span class="p">.</span><span class="n">Result</span><span class="p">&lt;</span><span class="nb">Int</span><span class="o">&gt;</span> <span class="p">=</span> <span class="n">someModule1Function</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">secondResult</span> <span class="p">=</span> <span class="n">Module2</span><span class="p">.</span><span class="n">Result</span><span class="p">&lt;</span><span class="nb">Int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">firstResult</span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span> <span class="p">}</span></code></pre></div>

<h2 id="conclusion-and-usage">Conclusion and usage</h2>

<blockquote>
<p>A <code>Result</code> implementation can be found in the <a href="https://github.com/mattgallagher/CwlUtils/blob/master/Sources/CwlUtils/CwlResult.swift?ts=3">CwlResult.swift</a> file of the <a href="https://github.com/mattgallagher/CwlUtils">CwlUtils repository</a>.</p>
</blockquote>

<p>The <a href="https://github.com/mattgallagher/CwlUtils/blob/master/Sources/CwlUtils/CwlResult.swift?ts=3">CwlResult.swift</a> file has no dependencies and you can just use the file alone, if you wish. Of course, the implementation of a <code>Result</code> type is so mind numbingly simple that you might not even need to use someone else&rsquo;s code – it&rsquo;s just a two case <code>enum</code>, aferall.</p>

<p>Swift&rsquo;s error handling doesn&rsquo;t cover all error passing scenarios. Disappointing but not a disaster. If you need to handle value/error results in your code outside of passing results to the caller, there&rsquo;s very little friction involved in switching to <code>Result</code> handling instead – they can both end up producing a very similar outcome.</p>

<p>I would absolutely prefer to see Swift&rsquo;s error handling extended so it covers a wider range of common scenarios but I&rsquo;ve been using a <code>Result</code> type to handle error passing in Swift since Swift&rsquo;s first public betas and I&rsquo;m not worried about the prospect of continuing to do so.</p>

<h3 id="looking-forward">Looking forward</h3>

<p>&ldquo;Asynchrony&rdquo; is going to be a major focus of the next half dozen (or more) articles on Cocoa with Love. Passing around <code>Result</code> is a big part of making that work.</p>

<h2 id="aside-1-why-then-does-the-standard-library-include-optional">Aside 1: Why then does the standard library include <code>Optional</code>?</h2>

<p>It&rsquo;s interesting to consider that where <code>Result</code> is rejected from the standard library, in favor of special language features and syntax, Swift contains a very similar type, <code>Optional</code> which looks like this:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Optional</span><span class="p">&lt;</span><span class="n">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">some</span><span class="p">(</span><span class="n">Wrapped</span><span class="p">)</span>
   <span class="k">case</span> <span class="kr">none</span>
<span class="p">}</span></code></pre></div>

<p>Both <code>Optional</code> and <code>Result</code> can be used to encapsulte the result of a function that may produce a result or fail. Both types can be processed via <code>map</code> and <code>flatMap</code> to handle the success case while short-circuiting the failure case.</p>

<p>In many ways, a <code>Result</code> is a <em>more</em> powerful <code>Optional</code>. In the &ldquo;not a value&rdquo; case, a <code>Result</code> allows metadata about why the state occurred.</p>

<p>Interestingly, despite being less powerful, an <code>Optional</code> is more <em>useful</em> because it is simpler. An <code>Optional</code> represents a basic toggle so it is well suited to representing basic boolean state (connected/disconnected, constructed/deleted, enabled/disabled, available/unavailable). Meanwhile <code>Result</code> is really constrained – by virtue of requiring <code>Error</code> metadata in <code>failure</code> cases – to being the output of an actual data flow.</p>

<h2 id="aside-2-either-types">Aside 2: <code>Either</code> types</h2>

<p>Another type, similar to <code>Result&lt;Value&gt;</code> that <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html">was suggested for the Swift standard library</a> and <a href="https://github.com/apple/swift-evolution/pull/67">ultimately rejected</a> was a biased <code>Either&lt;Left, Right&gt;</code> type that looks a little like this:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Either</span><span class="p">&lt;</span><span class="n">Left</span><span class="p">,</span> <span class="n">Right</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="kr">left</span><span class="p">(</span><span class="n">Left</span><span class="p">)</span>
   <span class="k">case</span> <span class="kr">right</span><span class="p">(</span><span class="n">Right</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>If you consider a fully typed <code>Result&lt;Value, ErrorType&gt;</code> like this:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Result</span><span class="p">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">ErrorType</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">success</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">failure</span><span class="p">(</span><span class="n">ErrorType</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p>then a left-biased <code>Either</code> type can be considered a more general form of the same type.</p>

<p>The discussion on this topic revealed that the proposers of an <code>Either</code> type were most interested in capturing the &ldquo;shape&rdquo; of different potential abstract operations. I understand the intent but attempting to capture the &ldquo;shape&rdquo; of operations is difficult enough in single parameter, strictly functional languages like Haskell but in multi-parameter imperative languages like Swift, the number of possible operations grows with each additional parameter and once side effects are involved, it becomes immediately unmanageable.</p>

<p>It&rsquo;s usually just easier to unwrap the <code>enum</code> when you need to operate on its contents, rather than relying on a large library of abstract and inefficient transformations.</p>

		</div>
	</article>
</main>

<div class="pagination">
  <div class="page-prev">
    Previous article:<br/><a href="../../07/30/timer-problems.html">Design patterns for safe timer usage</a>
  </div>
  <div class="page-next">
    Next article:<br/><a href="../23/result-types-part-two.html">Values and errors, part 2: eight languages compared</a>
  </div>
</div>


</div>
</div>

<footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Subscribe: <a href="../../../../feed.json">JSON</a>, <a href="../../../../feed.xml.rss">RSS</a> or <a href="https://apple.news/ToAaeVKb9TJOyYZi4sXnvXg">Apple News</a></li>
          <li>Twitter: <a href="https://twitter.com/cocoawithlove">@cocoawithlove</a></li>
          <li>Github: <a href="https://github.com/mattgallagher">mattgallagher</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>&copy; 2008-2017 Matt Gallagher. All rights reserved.<br/>Code may be used in accordance with license on <a href="../../../../about/index.html">About</a> page.<br/>If you need to contact me: <script type="text/javascript">
e1=('cocoa' + 'with' + 'love' + '&#46' + 'com')
e2=('info' + '&#64')
document.write('<a href="mailto:' + e2 + e1 + '">' + e2 + e1 + '</a>')
</script></p>
      </div>
    </div>

  </div>

</footer>

</body>

</html>
