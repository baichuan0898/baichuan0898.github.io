<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Values and errors, part 2: eight languages compared</title>
  <meta name="description" content="A concrete look at the languages studied by the Swift developers when designing Swift&#39;s approach to error handling. By comparing these to Swift, I&#39;ll try to better understand what balance the Swift developers sought on the topics of feature complexity, syntactic efficiency, abstraction, information signalling and safety." />

  <meta name="twitter:title" content="Values and errors, part 2: eight languages compared"/>
  <meta name="twitter:image" content="https://www.cocoawithlove.com/assets/site/touch_heartandcup.png"/>
  <meta name="twitter:url" content="https://www.cocoawithlove.com/blog/2016/08/23/result-types-part-two.html"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:description" content="A concrete look at the languages studied by the Swift developers when designing Swift&#39;s approach to error handling. By comparing these to Swift, I&#39;ll try to better understand what balance the Swift developers sought on the topics of feature complexity, syntactic efficiency, abstraction, information signalling and safety."/>

  <link rel="icon" href="../../../../assets/site/heartandcup.png" />
  <link rel="apple-touch-icon" href="../../../../assets/site/touch_heartandcup.png" />
  <link rel="stylesheet" href="../../../../css/main.css" />
  <link rel="canonical" href="result-types-part-two.html" />

  
</head>

<body>

<div class="hidetopextension"></div>
<header class="nav-header">
  <div class="wrapper">
  	<a href="../../../../index.html"><img class="heartandcup" src="../../../../assets/site/heartandcup.svg"></a>
  	<a class="top" href="#">top</a>
    <nav class="site-nav" onClick="if (this.className == 'site-nav') { this.className = 'site-nav-collapsed'; } else { this.className = 'site-nav'; }">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="../../../../about/index.html">about</a>
        <a class="page-link" href="../../../../archive/index.html">archive</a>
        <a class="page-link" href="../../../../search/index.html">search</a>
        <a class="page-link" href="http://zqueue.com/">zqueue.com</a>
      </div>
    </nav>
  </div>
</header>

<div class="nav-header-baseline"></div>

<div class="wrapper"><div class="hidetop"></div></div>

<header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="../../../../index.html">
      <img class="site-banner" alt="Matt Gallagher: Cocoa with Love" src="../../../../assets/site/banner.svg" width="720px" height="135px">
    </a>
  </div>
</header>

<div class="banner-baseline"></div>

<div class="page-content">
<div class="wrapper">


<header class="post-header">
	<h1 class="post-title" itemprop="headline">Values and errors, part 2: eight languages compared</h1>
	<div class="post-meta"><time itemprop="datePublished" datetime="2016-08-23">August 23, 2016</time> by Matt Gallagher</div>
	<div class="post-tags">Tags:
		
			<a href="../../../../tags/swift.html">Swift</a>, <a href="../../../../tags/error-handling.html">error handling</a>
		 
	</div>
</header>


<main role="main">
	<article itemscope itemtype="http://schema.org/BlogPosting">
		<div class="post-content" itemprop="articleBody">
			

<p>I&rsquo;m going to look at an error handling example implemented across a range of different languages studied by the Swift developers when designing Swift&rsquo;s approach to error handling. By comparing these languages to Swift, I&rsquo;ll try to better understand the balance of feature complexity, syntactic efficiency, abstraction, information signalling and safety that typical Swift code is expected to offer.</p>

<nav id="TableOfContents"><span class="toc-heading">Contents</span>
<ul>
<li>
<ul>
<li><a href="#learning-about-languages-via-error-handling">Learning about languages via error handling</a></li>
<li><a href="#swift">Swift</a></li>
<li><a href="#c">C</a>
<ul>
<li><a href="#what-does-this-tell-us-about-c">What does this tell us about C?</a></li>
<li><a href="#what-does-this-tell-us-about-swift">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#objective-c">Objective-C</a>
<ul>
<li><a href="#what-does-this-tell-us-about-objective-c">What does this tell us about Objective-C?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-1">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#c-1">C++</a>
<ul>
<li><a href="#what-does-this-tell-us-about-c-1">What does this tell us about C++?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-2">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#haskell">Haskell</a>
<ul>
<li><a href="#what-does-this-tell-us-about-haskell">What does this tell us about Haskell?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-3">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#java">Java</a>
<ul>
<li><a href="#what-does-this-tell-us-about-java">What does this tell us about Java?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-4">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#c-2">C#</a>
<ul>
<li><a href="#what-does-this-tell-us-about-c-2">What does this tell us about C#?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-5">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#rust">Rust</a>
<ul>
<li><a href="#what-does-this-tell-us-about-rust">What does this tell us about Rust?</a></li>
<li><a href="#what-does-this-tell-us-about-swift-6">What does this tell us about Swift?</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#looking-forward">Looking forward</a></li>
</ul></li>
</ul></li>
</ul>
</nav>

<h2 id="learning-about-languages-via-error-handling">Learning about languages via error handling</h2>

<p>The <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#survey">&ldquo;Survey&rdquo; section of the ErrorHandlingRationale</a> briefly discusses error propagation in C, C++, Objective-C, Java, C#, Haskell, Rust, Go and common scripting languages. Since I personally maintain professional projects in 5 of those languages (and I&rsquo;ve written projects in most of the rest) the topic makes me reflect on the approaches I use for error handling in each language; whether I&rsquo;m writing the best code I can, given the constraints and expected idioms of each language.</p>

<p>So I wanted to take a concrete look at error handling in the languages mentioned and see if I could learn more about those languages or more about Swift itself by directly comparing error handling approaches. Following the discussion from the <a href="../21/result-types-part-one.html">previous article</a>, I want to ensure consideration of approaches beyond simple synchronous errors, so I will use an example that includes two different kinds of error routing:</p>

<ol>
<li>Passing a value or recoverable error result from a function to its caller</li>
<li>Invoking a callback function, passing a value or error as an argument</li>
</ol>

<p>Unlike the <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst">ErrorHandlingRationale</a> document:</p>

<ul>
<li>I will consider only common use recoverable errors</li>
<li>I won&rsquo;t be considering scope cleanup issues</li>
<li>I&rsquo;m not going to look at Go or any scripting languages since I don&rsquo;t use them often enough to be insightful</li>
</ul>

<h2 id="swift">Swift</h2>

<p>I&rsquo;m going to start with a reference implementation in Swift. Assuming a <code>Result</code> type that includes a constructor from a Swift error handling <code>throws</code> function, as described in the <a href="../21/result-types-part-one.html#implications-of-no-result-type-in-the-standard-library">previous article</a>, the example looks like this:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// A function with a synchronous error result (Swift error handling)</span>
<span class="kd">func</span> <span class="nf">evenTimeValue</span><span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">UInt64</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">mach_absolute_time</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">case</span> <span class="kd">let</span> <span class="nv">t</span> <span class="k">where</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">t</span>
   <span class="k">default</span><span class="p">:</span> <span class="k">throw</span> <span class="n">TimeError</span><span class="p">.</span><span class="n">expectedEvenGotOdd</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">TimeError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{</span> <span class="k">case</span> <span class="n">expectedEvenGotOdd</span> <span class="p">}</span>

<span class="c1">// A continuation passing style wrapper (Swift error handling to Result handling)</span>
<span class="kd">func</span> <span class="nf">cpsEvenTime</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="nb">UInt64</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">callback</span><span class="p">(</span><span class="n">Result</span> <span class="p">{</span> <span class="k">try</span> <span class="n">evenTimeValue</span><span class="p">()</span> <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// This is the top level that invokes the continuation passing style wrapper</span>
<span class="c1">// around `evenTimeValue` and passes it a closure that ultimately processes the result </span>
<span class="n">cpsEvenTime</span> <span class="p">{</span> <span class="n">timeResult</span> <span class="k">in</span>
   <span class="k">switch</span> <span class="n">timeResult</span> <span class="p">{</span>
   <span class="k">case</span> <span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="kd">let</span> <span class="nv">value</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
   <span class="k">case</span> <span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="kd">let</span> <span class="nv">error</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 16 lines (excluding blank lines and comments), 2 <code>switch</code> statements, 2 closures, 7 function calls. <strong>Safety concerns</strong>: No language support for <code>Result</code> means it is possible to accidentally ignore <code>timeResult</code>.</p>
</blockquote>

<h2 id="c">C</h2>

<p>Typical implementations use an <code>int</code> return to indicate &ldquo;success&rdquo; (often zero) or  &ldquo;failure&rdquo; (often a non-zero error code) and return their results through an out-pointer:</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Synchronous error result (int error code, result by out-pointer)
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">evenTimeValue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mach_absolute_time</span><span class="p">();</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Continuation passing style wrapper (code and value passed into function pointer)
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">cpsEvenTime</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">))</span> <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="n">evenTimeValue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
   <span class="n">callback</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// C has no anonymous functions (lambdas/closures) so the handler is a declared function
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">handleResult</span><span class="p">(</span><span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1">// around `evenTimeValue` and passes it a pointer to a function that ultimately processes
</span><span class="c1">// the result 
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">cpsEvenTime</span><span class="p">(</span><span class="n">handleResult</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 25 lines (excluding blank lines and comments), 2 <code>if</code>/<code>else</code> statements, 1 function pointer, 1 out-pointer, 6 function calls. <strong>Safety concerns</strong>: No language support means it is possible to omit any check of the <code>code</code> and get an uninitialized <code>t</code> value.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-c">What does this tell us about C?</h3>

<p>C aims to be simple by offering a minimal set of language features and relying on the programmer to understand problems like undefined behavior and avoid them. Good programming in C requires a simple and methodical approach. It&rsquo;s possible to write abstractions in C but generally, programmers work in C because they want a raw pointer and the freedom to process things themselves, one byte at a time if necessary.</p>

<p>The reality is that C could get a little closer to the <em>spirit</em> of the Swift implementation through its <code>union</code> type – which could encapsulate a value or error disjunction in a single data type but a manually tagged union is clumsy and adds layers of complexity with no additional safety. Ultimately, layers of abstraction like this conflict with a typical C design philosophy and are typically avoided. There&rsquo;s a whole world of preprocessor hacks that attempt to make different design patterns like this manageable in C but that&rsquo;s really just one leaky abstraction on top of another.</p>

<h3 id="what-does-this-tell-us-about-swift">What does this tell us about Swift?</h3>

<p>Like C, Swift aspires to be simple, but Swift and C disagree on what simple is. Swift aims for simplicity by offering clear tools to solve common problems and minimizing the possibility of mistakes.</p>

<h2 id="objective-c">Objective-C</h2>

<p>In principal, Objective-C inherits C&rsquo;s error handling, which is to say that it doesn&rsquo;t have any language supported error handling. By convention though, Objective-C uses a slightly different style, returning an object pointer on success and <code>nil</code> on failure, plus an optional <code>NSError **</code> out parameter with details.</p>

<div class="highlight"><pre class="chroma"><code class="language-objc" data-lang="objc"><span class="c1">// It wouldn&#39;t be Objective-C without some boilerplate
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">TimeSource</span>: <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="c1">// And some file-scoped definitions
</span><span class="c1"></span><span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">TimeSourceErrorDomain</span> <span class="o">=</span> <span class="s">@&#34;TimeSourceError&#34;</span><span class="p">;</span>
<span class="n">NSInteger</span> <span class="n">TimeSourceExpectedEvenGotOdd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">@implementation</span> <span class="nc">TimeSource</span>

<span class="c1">// Synchronous error result (nil value means error, errorOut may be NULL)
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="nf">evenTimeValueWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">errorOut</span> <span class="p">{</span>
   <span class="n">uint64_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mach_absolute_time</span><span class="p">();</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="l">@(</span><span class="n">t</span><span class="l">)</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errorOut</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">*</span><span class="n">errorOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSError</span>
            <span class="nl">errorWithDomain</span><span class="p">:</span><span class="n">TimeSourceErrorDomain</span>
            <span class="nl">code</span><span class="p">:</span><span class="n">TimeSourceExpectedEvenGotOdd</span>
            <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Continuation passing style wrapper (code and value passed into block parameter)
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">cpsEvenTime:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="p">))</span><span class="nv">callback</span> <span class="p">{</span>
   <span class="n">NSError</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
   <span class="n">NSNumber</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">evenTimeValueWithError</span><span class="p">:</span><span class="o">&amp;</span><span class="n">e</span><span class="p">];</span>
   <span class="n">callback</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1">// around `evenTimeValue` and passes it a closure that ultimately processes the
</span><span class="c1">// result 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">[</span><span class="n">TimeSource</span> <span class="nl">cpsEvenTime</span><span class="p">:</span> <span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">[[</span><span class="n">t</span> <span class="n">description</span><span class="p">]</span> <span class="n">UTF8String</span><span class="p">]);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">[[</span><span class="n">e</span> <span class="n">localizedDescription</span><span class="p">]</span> <span class="n">UTF8String</span><span class="p">]);</span>
      <span class="p">}</span>
   <span class="p">}];</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 32 lines (excluding blank lines and comments and unwrapping ), 2 <code>if</code>/<code>else</code> statements and an <code>if</code> statement, 1 closure, 1 out-pointer, 4 function calls, 7 method invocations. <strong>Safety concerns</strong>: It is possible to omit any check of the <code>t</code> value and get Objective-C&rsquo;s no-op when messaging <code>nil</code> or worse, use the <code>nil</code> pointer where non-<code>nil</code> is required.</p>
</blockquote>

<p>I&rsquo;m fond of Objective-C but this example emphasizes a lot of its worst aspects. It&rsquo;s verbose, full of structural boilerplate, over-reliant on heap allocations and while the &ldquo;<code>nil</code> messaging is no-op&rdquo; pattern (inherent in the <code>NSNumber *</code> result) reduce crashes in Objective-C versus C, it doesn&rsquo;t guarantee correct behavior and may make problems harder to track down.</p>

<h3 id="what-does-this-tell-us-about-objective-c">What does this tell us about Objective-C?</h3>

<p>Objective-C tries to handle most problems as object-oriented design problems but when that doesn&rsquo;t work, it falls back to plain C. Composite value/error result handling falls outside basic object-oriented design so Objective-C offers little over C except some slightly more consistent standard patterns. However, some of those standard patterns in Objective-C involve some running around – this is a prime example.</p>

<h3 id="what-does-this-tell-us-about-swift-1">What does this tell us about Swift?</h3>

<p>Objective-C&rsquo;s standard approach for error handling was objectively mediocre. It was never obviously a focus of the langauge. While Swift inherits many ideas from Objective-C, error handling is <em>not</em> among them.</p>

<p>When interoperating with Objective-C, all of this work may still occur but it&rsquo;s such straightforward boilerplate that Swift can do it automatically.</p>

<h2 id="c-1">C++</h2>

<p>This is tricky because there&rsquo;s no universally used approach for error handling in C++.</p>

<p>Many of C++&rsquo;s features are controversial. <a href="../../05/01/swift-name-demangling.html#c-exceptions-versus-swift-error-handling">I&rsquo;ve previously discussed why many C++ programmers disable exceptions</a>. Some C++ programmers use compilers that don&rsquo;t support lamdas. Others avoid templates for compile-time performance reasons or historical bugs in the template implementations of some compilers. Even where templates are used, some C++ programmers avoid large common libraries like &ldquo;boost&rdquo; due to poor compilation performance and lack of modularity.</p>

<p>The result is that there are hundreds of little sub-domains within C++ built around a specific subset of features, written as though all the other features of the language don&rsquo;t exist – because they might not.</p>

<p>For handling disjunctions over value or error results, the following are used to varying degrees:</p>

<ul>
<li>Variations on C-style error handling (result code plus out-pointer).</li>
<li>C++ exceptions</li>
<li>Tagged unions using <code>boost::variant</code> (or <code>std::variant</code> in C++17)</li>
</ul>

<p>I&rsquo;m going to use the latter two, even though the first might be the most universal (I&rsquo;ve already written a section in C for this article).</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/variant.hpp&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// Synchronous error result (throws exception on error)
</span><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">evenTimeValue</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">uint64_t</span> <span class="n">mach_absolute_time</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mach_absolute_time</span><span class="p">();</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;Expected even time, got odd&#34;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Continuation passing style wrapper (error string or value in a tagged union)
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">cpsEvenTime</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span>
   <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">try</span> <span class="p">{</span>
      <span class="n">callback</span><span class="p">(</span><span class="n">evenTimeValue</span><span class="p">());</span>
   <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">callback</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1">// around `evenTimeValue` and passes it a lambda that ultimately processes the
</span><span class="c1">// result 
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">cpsEvenTime</span><span class="p">([](</span><span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
      <span class="p">}</span>
   <span class="p">});</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 27 lines (ignoring blank lines and comments), 2 <code>if</code>/<code>else</code> statements, a <code>try</code>/<code>catch</code>, 1 potential <code>throw</code>, 1 lambda, 4 function calls, 13 function calls. <strong>Safety concerns</strong>: It is possible to omit the <code>try</code>/<code>catch</code> and have the exception propagate to a surrounding scope. You could also accidentally ignore the <code>result</code> or misapply the <code>boost::get</code> and trigger a runtime abort.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-c-1">What does this tell us about C++?</h3>

<p>C++ incorporates many distinct philosophies. C-style programming is a common denominator for most – but not all. There&rsquo;s usually a few tools to solve any problem but there&rsquo;s no guarantee any of them will play well with your own style of C++.</p>

<p>C++ is typesafe and usually avoids pointers of any kind but that doesn&rsquo;t mean it&rsquo;s completely <em>robust</em>, since you can forget to catch an exception or use the wrong <code>boost::get</code> and trigger another exception or unwanted <code>abort</code> – there are lots of potential ways to accidentally trigger runtime errors (it&rsquo;s difficult to avoid partial functions).</p>

<p>Additionally, despite a reputation for being a kitchen sink of every language feature, I needed to use <code>boost::variant</code> in the example, rather than a standard library feature or an actual inbuilt language feature to get a basic tagged union. C++17 will finally add this to the standard library but it&rsquo;s still not as good as adding it to the language itself (it will still be prone to runtime, rather than compile-time type checking).</p>

<h3 id="what-does-this-tell-us-about-swift-2">What does this tell us about Swift?</h3>

<p>Given that all of the Swift compiler developers are themselves C++ developers, it is interesting that Swift has turned out almost, but not quite, entirely unlike C++. While Swift&rsquo;s error handling offers potentially similar control flow to C++ exceptions, C++ exceptions provided the clearest example of what the Swift developers wanted to avoid with Swift.</p>

<p>Swift would also rather solve problems with clear syntax rather than the numerous safe implementation rules required in C++. The <code>defer</code> syntax used to manage cleanup at scope exit, including around thrown errors, is an example of language syntax avoiding the need for safe implementation rules like <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>.</p>

<h2 id="haskell">Haskell</h2>

<p>Errors in Haskell are typically represented as an <code>Either</code>, <code>Maybe</code> or an <code>IO</code> monad type. In Haskell, the <code>flatMap</code> operation from Swift is called <code>bind</code> and it is typically invoked using the <code>&gt;&gt;=</code> operator (or implicitly handled using <code>do</code> notation).</p>

<p>Since Haskell is less likely to be well understood by readers of Cocoa with Love, I&rsquo;ve thoroughly commented this code so if you can&rsquo;t read the Haskell, you can at least read about what is happening here.</p>

<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Time.Clock.POSIX</span>
<span class="kr">import</span> <span class="nn">Control.Exception</span>

<span class="c1">-- ** A function with an IO monad wrapped Integer result **</span>
<span class="c1">-- Please excuse everything to the left of `getPOSIXTime` here; it&#39;s just to</span>
<span class="c1">-- generate a time value as an integer.</span>
<span class="c1">-- The actual test for even/odd occurs in the `evenOrFail` helper function</span>
<span class="nf">evenTimeValue</span> <span class="ow">=</span> <span class="nf">round</span> <span class="o">.</span> <span class="p">(</span><span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">getPOSIXTime</span> <span class="o">&gt;&gt;=</span> <span class="nf">evenOrFail</span>

<span class="c1">-- ** Pattern matching helper function with an IO monad wrapped Integer result **</span>
<span class="c1">-- Tests t for odd or even, triggering an error if it is odd</span>
<span class="c1">-- This function is intended to be used with a `&gt;&gt;=` operator since it</span>
<span class="c1">-- takes a bare value and returns an `IO` monad wrapped value</span>
<span class="nf">evenOrFail</span> <span class="nf">t</span>
   <span class="o">|</span> <span class="nf">mod</span> <span class="nf">t</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="nf">return</span> <span class="nf">t</span>
   <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">fail</span> <span class="s">&#34;Expected even&#34;</span>

<span class="c1">-- ** Continuation passing style wrapper around `evenTimeValue` (empty IO monad result) **</span>
<span class="c1">-- Passing the result from `evenTimeValue` into the callback `c` is effortless</span>
<span class="c1">-- since errors from functions and errors as parameters have the same monad</span>
<span class="c1">-- representation in Haskell</span>
<span class="nf">cpsEvenTime</span> <span class="nf">c</span> <span class="ow">=</span> <span class="nf">c</span> <span class="nf">evenTimeValue</span>

<span class="c1">-- ** Callback function (empty IO monad result) **</span>
<span class="c1">-- Processing the value occurs with another `&gt;&gt;=` operator. Processing</span>
<span class="c1">-- the error requires a `catch` and redirect to the `onError` handler</span>
<span class="nf">callback</span> <span class="nf">t</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">t</span> <span class="o">&gt;&gt;=</span> <span class="nf">print</span><span class="p">)</span> <span class="p">`</span><span class="nf">catch</span><span class="p">`</span> <span class="nf">onError</span>

<span class="c1">-- ** Error handling helper function (empty IO monad result) **</span>
<span class="c1">-- Separate error handling function</span>
<span class="nf">onError</span> <span class="ow">::</span> <span class="kt">IOError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">onError</span> <span class="nf">e</span> <span class="ow">=</span> <span class="nf">print</span> <span class="p">(</span><span class="s">&#34;Error: &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="p">(</span><span class="nf">e</span><span class="p">))</span>

<span class="c1">-- ** Invoke everything at the top level (has an implicit empty IO monad result) **</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="nf">cpsEvenTime</span> <span class="nf">callback</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 11 lines (ignoring blank lines and comments), 1 pattern match, 2 bind operators, 1 <code>catch</code>, 6 different symbolic operators. <strong>Safety concerns</strong>: It is possible to accidentally omit the <code>catch</code> and have the error bubble, like a fatal exception, all the way to the top level.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-haskell">What does this tell us about Haskell?</h3>

<p>Ignoring the bulk added by the comments, this code is quite compact. It&rsquo;s not exactly simpler or doing less than the Swift example, rather, Haskell avoids braces and makes heavy use of symbolic operators so it crams a lot of work into a small space.</p>

<p>Haskell&rsquo;s error handling is fundamentally anchored in monads. Often these are &ldquo;one-way&rdquo; monads (where you can never pattern match and unwrap, you can only bind or catch to process the possible cases).</p>

<p>Haskell has many good aspects when it comes to code correctness and error handling:</p>

<ul>
<li>memory safe programming language</li>
<li>fewer <a href="../../01/25/partial-functions-part-one-avoidance.html">partial functions</a> than common imperative languages so you&rsquo;re less unlikely to see exceptions/aborts</li>
<li>no force unwrapping or other cheating</li>
</ul>

<p>However, Haskell&rsquo;s approach to error handling does have some limitations. Specifically, monadic handling makes it very easy to &ldquo;bind&rdquo; (<code>&gt;&gt;=</code>) to get the &ldquo;success&rdquo; result and totally ignore what happens in an error case. Monadic handling encourages the ignoring of errors. If this code had omitted the <code>catch</code> handling, the <code>IO</code> monad would have propagated all the way to the output of the <code>main</code> function.</p>

<p>There&rsquo;s also an almost total lack of signalling. Unless you look for the bind operator, <code>do</code> notation or the <code>catch</code>, <code>return</code> or <code>fail</code> functions, it&rsquo;s difficult to know where <code>IO</code> or other monads are involved. Haskell&rsquo;s pervasive type inferencing is often a hindrance here: only one of these functions is required to actually specify a type signature.</p>

<h3 id="what-does-this-tell-us-about-swift-3">What does this tell us about Swift?</h3>

<p>Swift&rsquo;s <code>do</code> and <code>Result</code> handling have a lot in common with Haskell&rsquo;s <code>do</code> and monads. The difference is that Swift avoids wrapping your data types and therefore allows you to manage the data flow without any wrappers or abstractions.</p>

<p>While downplaying abstractions, Swift plays <em>up</em> control flow and signalling of potential actions with keywords like <code>try</code> for signalling the existince of error handling in a statement where equivalent handling in Haskell may be subtler to detect.</p>

<h2 id="java">Java</h2>

<p>Java includes the closest parallel to Swift&rsquo;s inbuilt error handling with its &ldquo;checked exceptions&rdquo;. Like Swift&rsquo;s <code>throws</code>, the possibility of throwing is part of a function&rsquo;s signature and may not be ignored by the caller.</p>

<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeSource</span> <span class="o">{</span>
   <span class="c1">// A function with declared &#34;checked&#34; exception
</span><span class="c1"></span>   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">evenTimeValue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
      <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="o">(</span><span class="s">&#34;Expected even, got odd&#34;</span><span class="o">);</span>
      <span class="o">}</span>
   <span class="o">}</span>
   
   <span class="c1">// A continuation passing style wrapper (passing value and error arguments)
</span><span class="c1"></span>   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">cpsEvenTime</span><span class="o">(</span><span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">IOException</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
         <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="k">new</span> <span class="n">Long</span><span class="o">(</span><span class="n">evenTimeValue</span><span class="o">()));</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1"></span>   <span class="c1">// around `evenTimeValue` and passes it a lambda that ultimately processes the
</span><span class="c1"></span>   <span class="c1">// result 
</span><span class="c1"></span>   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">TimeSource</span><span class="o">.</span><span class="na">cpsEvenTime</span><span class="o">((</span><span class="n">error</span><span class="o">,</span> <span class="n">time</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">error</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
         <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">time</span><span class="o">);</span>
         <span class="o">}</span>
      <span class="o">});</span>
   <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 28 lines (ignoring blank lines and comments), 2 <code>if</code>/<code>else</code> statements, a <code>try</code>/<code>catch</code>, 1 potential <code>throw</code>, 1 lambda, 10 methods. <strong>Safety concerns</strong>: It is possible to forget to check the <code>error</code> for <code>null</code> and use an invalid value.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-java">What does this tell us about Java?</h3>

<p>In this example, Java&rsquo;s use of <code>throws</code>, <code>throw</code> and <code>catch</code> closely resemble Swift&rsquo;s matching keywords. However, while methods that throw &ldquo;checked exceptions&rdquo; are always marked, sites that <em>use</em> these functions are not marked – if the <code>IOException</code> had been generated inside a function, there would not need to be any mention of that in this source code.</p>

<p>Negatives of the approach for common error handling include:</p>

<ol>
<li>In Java, the exception types thrown must be fully enumerated – a difference that is sometimes an advantage and sometimes a burden. I&rsquo;ll look at the problems this causes <a href="#c-2">in the C# section, below</a>.</li>
<li>Java&rsquo;s <code>Exception</code> class captures a full stack trace and other information, which, along with allocation overhead and exception hander overhead, <a href="http://stackoverflow.com/questions/299068/how-slow-are-java-exceptions">makes it 60 times slower than returning an error code</a></li>
<li>The name &ldquo;exception&rdquo; leads to reasonable questions about whether it should be regularly used or used only in exceptional circumstances.</li>
</ol>

<p>Ignoring poor performance, the biggest problem affecting Java&rsquo;s checked exceptions is the existence of &ldquo;unchecked exceptions&rdquo;. While checked exceptions are usable for common errors, unchecked exceptions are absolutely for exceptional circumstances (programmer errors which should lead to an abort). Despite the fact that they should be a rarer choice, unchecked exceptions are actually easier to use, since they don&rsquo;t need to be declared.</p>

<p>Ultimately, declaration issues, performance issues and confusion with programmer errors lead to a signficantly compromised language feature.</p>

<h3 id="what-does-this-tell-us-about-swift-4">What does this tell us about Swift?</h3>

<p>While Swift has copied some of the syntactic elements of checked exceptions, Swift is very careful to avoid calling its errors &ldquo;exceptions&rdquo; since they are different in important ways. Most significantly, Swift&rsquo;s errors are as performant as returning an error code and have no overlap with technology intended for fatal errors.</p>

<p>Good performance and clear separation of concerns are important goals of Swift.</p>

<h2 id="c-2">C#</h2>

<p>I doubt it would be new information to anyone here but C#&rsquo;s syntax is very similar to Java to the point where you can&rsquo;t always immediately tell one from the other.</p>

<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">TimeSourceApplication</span> <span class="p">{</span>
   <span class="k">class</span> <span class="nc">TimeSource</span> <span class="p">{</span>
       <span class="c1">// A function that might throw an exception
</span><span class="c1"></span>       <span class="k">public</span> <span class="k">static</span> <span class="kt">long</span> <span class="n">evenTimeValue</span><span class="p">()</span> <span class="p">{</span>
          <span class="kt">long</span> <span class="n">t</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nc">DateTime</span><span class="p">.</span><span class="nc">Now</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
             <span class="k">throw</span> <span class="k">new</span> <span class="nc">System</span><span class="p">.</span><span class="n">Exception</span><span class="p">(</span><span class="s">&#34;Expected even, got odd.&#34;</span><span class="p">);</span>
          <span class="p">}</span>
       <span class="p">}</span>
   
       <span class="c1">// A continuation passing style wrapper (passing value and error arguments)
</span><span class="c1"></span>       <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">cpsEvenTime</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="nc">System</span><span class="p">.</span><span class="n">Exception</span><span class="p">,</span> <span class="kt">long</span><span class="p">&gt;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">try</span> <span class="p">{</span>
             <span class="n">callback</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">evenTimeValue</span><span class="p">());</span>
          <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">callback</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
          <span class="p">}</span>
       <span class="p">}</span>

      <span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1"></span>      <span class="c1">// around `evenTimeValue` and passes it a lambda that ultimately processes the
</span><span class="c1"></span>      <span class="c1">// result 
</span><span class="c1"></span>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="na">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="nc">TimeSource</span><span class="p">.</span><span class="n">cpsEvenTime</span><span class="p">((</span><span class="n">error</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">System</span><span class="p">.</span><span class="nc">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="nc">error</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nc">System</span><span class="p">.</span><span class="nc">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
             <span class="p">}</span>
          <span class="p">});</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 29 lines (ignoring blank lines and comments), 2 <code>if</code>/<code>else</code> statements, a <code>try</code>/<code>catch</code>, 1 potential <code>throw</code>, 1 lambda, 9 methods (including a getter). <strong>Safety concerns</strong>: You could accidentally omit the <code>try</code>/<code>catch</code> and have the exception propagate to the surrounding scope. It is also possible to forget to check the <code>error</code> for <code>null</code> and use an invalid value.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-c-2">What does this tell us about C#?</h3>

<p>On the topic of error handling, C# explicitly rejected Java&rsquo;s checked exceptions in favor of unchecked exceptions.</p>

<p><a href="http://www.artima.com/intv/handcuffs.html">Anders Hejlsberg, creator of C#, spoke about why checked exceptions were not included in C# in an interview in 2003</a>:</p>

<blockquote>
<p>Adding a new exception to a throws clause in a new version breaks client code. It&rsquo;s like adding a method to an interface. After you publish an interface, it is for all practical purposes immutable, because any implementation of it might have the methods that you want to add in the next version. So you&rsquo;ve got to create a new interface instead. Similarly with exceptions, you would either have to create a whole new method called foo2 that throws more exceptions, or you would have to catch exception D in the new foo, and transform the D into an A, B, or C.</p>
</blockquote>

<p>and he further states:</p>

<blockquote>
<p>The trouble begins when you start building big systems where you&rsquo;re talking to four or five different subsystems. Each subsystem throws four to ten exceptions. Now, each time you walk up the ladder of aggregation, you have this exponential hierarchy below you of exceptions you have to deal with. You end up having to declare 40 exceptions that you might throw. And once you aggregate that with another subsystem you&rsquo;ve got 80 exceptions in your throws clause. It just balloons out of control.</p>
</blockquote>

<p>The problem, as he sees it, is Java requires you explicitly enumerate every kind of exception that can be thrown. This is in contrast to Swift which simply says: &ldquo;an error may be thrown&rdquo; and makes matching error types a runtime concern.</p>

<h3 id="what-does-this-tell-us-about-swift-5">What does this tell us about Swift?</h3>

<p>The interesting point here then is that Swift has taken an approach closer to <em>checked</em> exceptions than C#&rsquo;s <em>unchecked</em> exceptions. Swift addresses Anders Hejlsberg&rsquo;s concerns about checked exceptions by removing the need to declare exception types but keeping the explicit use of the <code>throws</code> keyword.</p>

<p>Swift wants code that is easy to reason about accurately. Unmarked exceptions (i.e. no visible <code>try</code> or <code>throws</code> keyword in every function traversed) does not fit this desire.</p>

<h2 id="rust">Rust</h2>

<p>Rust and Swift are both products of modern programming language design and include similar aims (no null pointers, no undefined behavior and no memory unsafety outside of clearly identified &ldquo;unsafe&rdquo;). Each has borrowed ideas from the same sources and each has borrowed from the other. The two are very different when it comes to level of programmer involvement in managing ideas like reference ownership but even on this level, there&rsquo;s evidence that <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html">Swift may move a little closer to Rust</a> in the future.</p>

<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// A function with a synchronous error (Result return type)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">even_time_value</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">TimeSourceError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">std</span>::<span class="n">time</span>::<span class="n">UNIX_EPOCH</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()).</span><span class="n">as_secs</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">       </span><span class="n">t</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w">
</span><span class="w">       </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">TimeSourceError</span>::<span class="n">ExpectedEvenGotOdd</span><span class="p">),</span><span class="w">
</span><span class="w">   </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// An error type that includes cases for our generated error and a possible underlying
</span><span class="c1">// system error
</span><span class="c1"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">TimeSourceError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="n">ExpectedEvenGotOdd</span><span class="p">,</span><span class="w">
</span><span class="w">   </span><span class="n">SystemTimeError</span><span class="p">(</span><span class="n">std</span>::<span class="n">time</span>::<span class="n">SystemTimeError</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Helper function that re-wraps SystemTimeError as TimeSourceError (used in try!, above)
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">std</span>::<span class="n">time</span>::<span class="n">SystemTimeError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TimeSourceError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">std</span>::<span class="n">time</span>::<span class="n">SystemTimeError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">TimeSourceError</span>::<span class="n">SystemTimeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// A continuation passing style wrapper (Result passed as argument)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">cps_even_time_value</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">TimeSourceError</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="n">callback</span><span class="p">(</span><span class="n">even_time_value</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Program entry point that invokes the continuation passing style wrapper
</span><span class="c1">// around `evenTimeValue` and passes it a lambda that ultimately processes the
</span><span class="c1">// result 
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="n">cps_even_time_value</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w">
</span><span class="w">      </span><span class="k">match</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">         </span><span class="nb">Ok</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w">
</span><span class="w">         </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">   </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span></code></pre></div>

<blockquote>
<p><strong>Scorecard</strong>: 27 lines (excluding blank lines and comments), 2 <code>match</code> statements, 1 closure, 3 macros, 4 function calls. <strong>Safety concerns</strong>: None.</p>
</blockquote>

<h3 id="what-does-this-tell-us-about-rust">What does this tell us about Rust?</h3>

<p>Rust prides itself on being precise and opinionated. Precise reference ownership semantics, precise error typing, even debug printing is unavailable unless specifically requested (in this case, with the <code>derive(Debug)</code> attribute). This is also the only example where I&rsquo;ve altered the naming scheme to match the language since <code>evenTimeValue</code> gave a compiler warning: &ldquo;function <code>evenTimeValue</code> should have a snake case name such as <code>even_time_value</code>&rdquo;.</p>

<p>In accordance with the focus on being precise, Rust includes no automatic error propagation. Instead, you are merely forbidden (via the compiler attribute <code>#[must_use]</code>) from completely ignoring the <code>Result</code>. Beyond that, the behavior or propagation is completely manual.</p>

<p>However, Rust&rsquo;s macro system offers some tricks that smooth over the handling to the point where it almost looks like Swift&rsquo;s error handling. Specifically, the <code>try!</code> macro (the exclamation mark indicates a macro, not a force unwrap like Swift) expands to checking for an error, exiting early from the function if an error occurs and only proceeding if it gets a success. Since the <code>Err</code> case of the <code>Result</code> is handled by this macro, the output of the <code>try!</code> macro has the type of the <code>Ok</code> case, <code>u64</code>, rather than a <code>Result</code> wrapped type.</p>

<p>The effect is very similar to how Swift&rsquo;s error handling works inside a <code>throws</code> function but there&rsquo;s a complication: the fully typed errors used by Rust&rsquo;s <code>Result</code> type don&rsquo;t automatically compose like Swift&rsquo;s <code>Error</code> protocol does. Instead, <a href="https://doc.rust-lang.org/book/error-handling.html#composing-custom-error-types">composing custom error types in Rust</a> requires that we convert the underlying error to the appropriate type – which we do in this case with an implementation of the <code>From</code> trait (which is called from inside the <code>try!</code> macro to allow conversion).</p>

<h3 id="what-does-this-tell-us-about-swift-6">What does this tell us about Swift?</h3>

<p>Swift is less focussed on precision and control than Rust. Swift is happy to have errors fall under a single broad protocol (rather than precisely enumerating all possible sub-error types) to allow a smoother experience.</p>

<p>Swift is also happy to include compiler automated behaviors like propagation, provided there is clear signalling of possible behaviors. With the Rust <code>try!</code> macro in this example, the effect was very similar but Swift&rsquo;s approach will also work over successive <code>try</code> statements in a <code>do</code> scope within a single function (the Rust <code>try!</code> macro works only when it can exit from the current function).</p>

<h2 id="conclusion">Conclusion</h2>

<p>Swift&rsquo;s error handling is probably my favorite feature in the language because of the improvements it offers over alternatives while remaining familiar, simple to use and easy to reason about.</p>

<p>However, I&rsquo;m not exclusively a Swift programmer. I continue to program in other languages so I feel like there are also lessons from this investigation that I could apply back to some of the other languages I use.</p>

<p>In particular, I feel like I should experiment with <code>Result</code> types in C++, Java and C# to avoid problems with exceptions or the problems with using separate error codes and values. The generics/templates and lambdas in these languages are certainly capable of cleanly expressing this pattern. I do already use <code>boost::variant</code> in my C++ code but it&rsquo;s prone to accidental <code>boost::get</code> misuse and lacks transformations for composing errors – a dedicated <code>Result</code> type would be better.</p>

<p>For the other languages in this post, while I prefer Swift&rsquo;s error handling, the error handling approaches match the philosophy of the respective languages. Rust&rsquo;s <code>Result</code> type is safe, precise and avoids compiler inserted sugar while offering similar syntax in many cases to Swift&rsquo;s error handling. Haskell&rsquo;s error handling – and the possibilites afforded by monads and higher kinded types – is practically a religion for its adherents. Even C&rsquo;s approach (language does nothing, language user coordinates everything) could be considered appropriate for the language.</p>

<h3 id="looking-forward">Looking forward</h3>

<p>Writing code in multiple languages is mostly playing around. However, there&rsquo;s lots of ideas to borrow from all of the languages here. A number of design patterns that I hope to present in future articles have come to me via implementations in the languages here.</p>

		</div>
	</article>
</main>

<div class="pagination">
  <div class="page-prev">
    Previous article:<br/><a href="../21/result-types-part-one.html">Values and errors, part 1: &#39;Result&#39; in Swift</a>
  </div>
  <div class="page-next">
    Next article:<br/><a href="../../09/14/updating-cocoawithlove.html">Updating Cocoa with Love for Swift 3</a>
  </div>
</div>


</div>
</div>

<footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Subscribe: <a href="../../../../feed.json">JSON</a>, <a href="../../../../feed.xml.rss">RSS</a> or <a href="https://apple.news/ToAaeVKb9TJOyYZi4sXnvXg">Apple News</a></li>
          <li>Twitter: <a href="https://twitter.com/cocoawithlove">@cocoawithlove</a></li>
          <li>Github: <a href="https://github.com/mattgallagher">mattgallagher</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>&copy; 2008-2017 Matt Gallagher. All rights reserved.<br/>Code may be used in accordance with license on <a href="../../../../about/index.html">About</a> page.<br/>If you need to contact me: <script type="text/javascript">
e1=('cocoa' + 'with' + 'love' + '&#46' + 'com')
e2=('info' + '&#64')
document.write('<a href="mailto:' + e2 + e1 + '">' + e2 + e1 + '</a>')
</script></p>
      </div>
    </div>

  </div>

</footer>

</body>

</html>
