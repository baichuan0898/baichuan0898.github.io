<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Exponential time complexity in the Swift type checker</title>
  <meta name="description" content="One of the most annoying problems in Swift is when the compiler gives an &#39;Expression was too complex to be solved in a reasonable time&#39; error. I look at why this error occurs, how to avoid it and talk about how this should be solved in a future compiler update." />

  <meta name="twitter:title" content="Exponential time complexity in the Swift type checker"/>
  <meta name="twitter:image" content="https://www.cocoawithlove.com/assets/site/touch_heartandcup.png"/>
  <meta name="twitter:url" content="https://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:description" content="One of the most annoying problems in Swift is when the compiler gives an &#39;Expression was too complex to be solved in a reasonable time&#39; error. I look at why this error occurs, how to avoid it and talk about how this should be solved in a future compiler update."/>

  <link rel="icon" href="../../../../assets/site/heartandcup.png" />
  <link rel="apple-touch-icon" href="../../../../assets/site/touch_heartandcup.png" />
  <link rel="stylesheet" href="../../../../css/main.css" />
  <link rel="canonical" href="type-checker-issues.html" />

  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML.js"></script>
</head>

<body>

<div class="hidetopextension"></div>
<header class="nav-header">
  <div class="wrapper">
  	<a href="../../../../index.html"><img class="heartandcup" src="../../../../assets/site/heartandcup.svg"></a>
  	<a class="top" href="#">top</a>
    <nav class="site-nav" onClick="if (this.className == 'site-nav') { this.className = 'site-nav-collapsed'; } else { this.className = 'site-nav'; }">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="../../../../about/index.html">about</a>
        <a class="page-link" href="../../../../archive/index.html">archive</a>
        <a class="page-link" href="../../../../search/index.html">search</a>
        <a class="page-link" href="http://zqueue.com/">zqueue.com</a>
      </div>
    </nav>
  </div>
</header>

<div class="nav-header-baseline"></div>

<div class="wrapper"><div class="hidetop"></div></div>

<header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="../../../../index.html">
      <img class="site-banner" alt="Matt Gallagher: Cocoa with Love" src="../../../../assets/site/banner.svg" width="720px" height="135px">
    </a>
  </div>
</header>

<div class="banner-baseline"></div>

<div class="page-content">
<div class="wrapper">


<header class="post-header">
	<h1 class="post-title" itemprop="headline">Exponential time complexity in the Swift type checker</h1>
	<div class="post-meta"><time itemprop="datePublished" datetime="2016-07-12">July 12, 2016</time> by Matt Gallagher</div>
	<div class="post-tags">Tags:
		
			<a href="../../../../tags/swift.html">Swift</a>, <a href="../../../../tags/compiler.html">compiler</a>
		 
	</div>
</header>


<main role="main">
	<article itemscope itemtype="http://schema.org/BlogPosting">
		<div class="post-content" itemprop="articleBody">
			

<p>This article will look issues surrounding a Swift compiler error that repeatedly forces me to rewrite my code:</p>

<blockquote>
<p>error: expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions</p>
</blockquote>

<p>I&rsquo;ll look at examples that trigger this error and talk about negative effects beyond compiler errors that are caused by the same underlying issue. I&rsquo;ll look at why this occurs in the compiler and how you can work around the problem in the short term.</p>

<p>I&rsquo;ll also present a theoretical change to the compiler that would eliminate all this problem <del>permanently</del> <em>in most common cases</em> [see section titled <a href="#update-limitations">Update: Limitations</a>] by altering the algorithm involved to be linear time complexity instead of exponential time complexity, without otherwise changing the external behavior.</p>

<nav id="TableOfContents"><span class="toc-heading">Contents</span>
<ul>
<li>
<ul>
<li><a href="#errors-compiling-otherwise-valid-code">Errors compiling otherwise valid code</a></li>
<li><a href="#needlessly-long-compile-times">Needlessly long compile times</a></li>
<li><a href="#unexpected-behaviors">Unexpected behaviors</a></li>
<li><a href="#working-around-the-problem-in-our-code">Working around the problem in our code</a></li>
<li><a href="#swift-s-constraints-system-solver">Swift&rsquo;s constraints system solver</a></li>
<li><a href="#getting-more-complex-quickly">Getting more complex, quickly</a></li>
<li><a href="#linearizing-the-constraints-solver">Linearizing the constraints solver</a>
<ul>
<li><a href="#premise">Premise</a></li>
<li><a href="#re-solving-the-previous-example">Re-solving the previous example</a></li>
<li><a href="#propagating-constraints-from-right-to-left">Propagating constraints from right to left</a></li>
<li><a href="#propagating-constraints-from-left-to-right">Propagating constraints from left to right</a></li>
</ul></li>
<li><a href="#how-would-performance-compare">How would performance compare?</a></li>
<li><a href="#update-limitations">Update: limitations</a>
<ul>
<li><a href="#conditions-preventing-linearization">Conditions preventing linearization</a></li>
<li><a href="#explanation-of-the-first-condition">Explanation of the first condition</a></li>
<li><a href="#explanation-of-the-second-condition">Explanation of the second condition</a></li>
<li><a href="#consequences">Consequences</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</nav>

<h2 id="errors-compiling-otherwise-valid-code">Errors compiling otherwise valid code</h2>

<p>The following line will give an error if you try to compile it in Swift 3:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span></code></pre></div>

<p>This line is valid, unambiguous Swift syntax. This line <em>should</em> compile and ultimately optimize to a constant value.</p>

<p>But the line doesn&rsquo;t get past the Swift type checker. Instead, it emits an error that the expression is too complex to solve. It doesn&rsquo;t <em>look</em> complex, does it? It&rsquo;s 5 integer literals, 4 addition operators, two negation operators and a binding to a <code>Double</code> type.</p>

<p>How can an expression containing just 12 entities be &ldquo;too complex&rdquo;?</p>

<p>There are many other expressions that will cause the same problem. Most include some literals, some of the basic arithmetic operators and possibly some heavily overloaded constructors. Each of the following expressions will fail with the same error:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">7</span>

<span class="kd">let</span> <span class="nv">e</span><span class="p">:</span> <span class="p">[(</span><span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">String</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;1&#34;</span> <span class="p">},</span>
  <span class="p">{</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">String</span><span class="p">(</span><span class="o">-</span><span class="n">v</span><span class="p">)</span> <span class="p">}</span> <span class="o">+</span> <span class="s">&#34;2&#34;</span><span class="p">,</span>
  <span class="p">{</span> <span class="n">v</span> <span class="k">in</span> <span class="nb">String</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#34;3&#34;</span> <span class="p">}</span>
<span class="p">]</span>

<span class="kd">let</span> <span class="nv">f</span><span class="p">:</span> <span class="p">(</span><span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">=</span> <span class="p">{</span> <span class="n">x</span> <span class="k">in</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="p">}</span></code></pre></div>

<p>All of these are completely valid Swift syntax and the expected types for every term in every expression should be obvious to any Swift programmer but in each case, the Swift type checker fails.</p>

<blockquote>
<p>Update: in Swift 3.1, the following two examples which I had previously included, above, were fixed and now work (although the first is a little slow).</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;1&#34;</span> <span class="o">+</span> <span class="s">&#34;2&#34;</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&#34;3&#34;</span><span class="p">)</span> <span class="p">{</span> <span class="s">&#34;4&#34;</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$1</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">b</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span></code></pre></div>

<h2 id="needlessly-long-compile-times">Needlessly long compile times</h2>

<p>Errors aren&rsquo;t the only consequence of this problem. Try compiling the following line:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">g</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span></code></pre></div>

<p>This single line does compile without error but it takes a whopping 20 seconds to compile in Swift 3.1 on my computer. The compiler spends almost all of this time in the Swift type checker.</p>

<p>Now, you probably don&rsquo;t have many lines that take <em>this</em> long to compile but it&rsquo;s virtually guaranteed that any non-trivial Swift project is taking at least a little longer than necessarily to compile due to the same complexity problem that causes the &ldquo;expression was too complex to be solved in reasonable time&rdquo; error.</p>

<blockquote>
<p>Update: I had previously used the following example in this section but it got fixed in Swift 3.1 and now appears to run quite quickly:</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="p">}(</span><span class="mi">0</span><span class="p">)</span></code></pre></div>

<h2 id="unexpected-behaviors">Unexpected behaviors</h2>

<p>I want to highlight a quirk in the Swift type checker: the type checker will choose to resolve overloaded operators to non-generic overloads whenever possible. The code comments for the path that handles this specific behavior in the compiler note that this behavior exists as an optimization to avoid performance issues – the same performance issues responsible for the &ldquo;expression was too complex&rdquo; error.</p>

<p>To see what effects this has, let&rsquo;s look at the following code:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code></pre></div>

<p>This code doesn&rsquo;t compile. Instead, we get an error &ldquo;Ambiguous use of operator &lsquo;-&rsquo;&rdquo;.</p>

<p>This shouldn&rsquo;t really be ambiguous; the compiler should realize we&rsquo;re using a integer literal, treat the <code>1</code> as an <code>Int</code> and select the following overload from the standard library:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">prefix</span> <span class="kd">public</span> <span class="kd">func</span> <span class="o">-&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">SignedNumber</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span></code></pre></div>

<p>However, Swift considers only the non-generic overloads; in this case, the <code>Float</code>, <code>Double</code> and <code>Float80</code> implementations, all of which are equally imperfect (non-preferred creation from an integer literal). The compiler can&rsquo;t choose one so it bails out with the error.</p>

<p>This particular optimization is applied <em>only</em> to operators, leading to the following inconsistency:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Float</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Float</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">f</span><span class="p">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="n">I</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">I</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="kr">prefix</span> <span class="kd">operator</span> <span class="o">%%</span> <span class="p">{}</span>
<span class="kr">prefix</span> <span class="kd">func</span> <span class="o">%%</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Float</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Float</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>
<span class="kr">prefix</span> <span class="kd">func</span> <span class="o">%%&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="n">I</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">I</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="o">%%</span><span class="mi">1</span></code></pre></div>

<p>This code defines two function names (<code>f</code> and a custom operator <code>prefix %%</code>). Each of these function names has two overloads, <code>(Float) -&gt; Float</code> and <code>&lt;I: Integer&gt;(I) -&gt; I</code>.</p>

<p>Calling <code>f(1)</code> selects the <code>&lt;I: Integer&gt;(I) -&gt; I</code> implementation and <code>x</code> is an <code>Int</code>. This is exactly what you&rsquo;d expect.</p>

<p>Calling <code>%%1</code> selects the <code>(Float) -&gt; Float</code> implementation and <code>y</code> is a <code>Float</code>, contrary to expectations. The code has chosen to convert <code>1</code> to a <code>Float</code>, against the preference for <code>Int</code> – despite the fact that <code>Int</code> would also work – because the compiler bails out before it considers the generic overload of the function. It&rsquo;s not really a semantically consistent choice, it&rsquo;s the result of a compromise in the compiler to avoid the &ldquo;expression was too complex to be solved&rdquo; error and its associated performance problems.</p>

<h2 id="working-around-the-problem-in-our-code">Working around the problem in our code</h2>

<p>In general, Swift&rsquo;s complexity problem won&rsquo;t be an issue unless you&rsquo;re using two or more of the following features in a single expression:</p>

<ul>
<li>overloaded functions (including operators)</li>
<li>literals</li>
<li>closures without explicit types</li>
<li>expressions where Swift&rsquo;s default &ldquo;every integer literal is an <code>Int</code> and every float literal is a <code>Double</code>&rdquo; choice is wrong</li>
</ul>

<p>If you don&rsquo;t typically combine these features in your code, then you&rsquo;re unlikely to see the &ldquo;expression was too complex&rdquo; error. However, if you <em>are</em> using these features, it isn&rsquo;t always straightforward to suddenly stop. Mathematics code, large functional-style expressions and declarative code are easier to write with these features and often require a complete rethink to avoid them.</p>

<p>You may prefer to give the compiler a little nudge so that it will accept your code without major changes. There are a few different approaches that can help.</p>

<p>The compiler error suggests &ldquo;breaking up the expression into distinct sub-expressions&rdquo;:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x_1</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">x_2</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">x_2</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span></code></pre></div>

<p>Okay, technically that works but it&rsquo;s really annoying – especially on small expressions where it only hurts legibility.</p>

<p>Another option is to reduce the number of function and operator overloads that the compiler must consider, by adding typecasts.</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="nb">Double</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="nb">Double</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="nb">Double</span></code></pre></div>

<p>This will prevent <code>(Float) -&gt; Float</code> or <code>(Float80) -&gt; Float80</code> being explored as one of the possible overloads for the negation operator, effectively reducing a system with 6 unknown functions to a system with just 4.</p>

<p>A note about this approach though: unlike other languages, <code>Double(x)</code> is not equivalent to <code>x as Double</code> in Swift. The constructor works more like another function and since it has multiple overloads on its parameter, it actually introduces another overloaded function into the search space (albeit at a different location in the expression). While the previous example will solve if you introduce <code>Double</code> around the parentheses (since the way the graph is rearranged favors the type checker), there are some cases where a similar approach can actually make things worse (see the <code>String</code> examples near the top of the article). Ultimately, the <code>as</code> operator is the only way to cast without inserting further complexity. Fortunately, <code>as</code> binds tighter than most binary operators so it can be used without parentheses in most cases.</p>

<p>Another approach is to use a uniquely named custom function:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="n">myCustomDoubleNegation</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">myCustomDoubleNegation</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
   <span class="o">+</span> <span class="n">myCustomDoubleNegation</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span></code></pre></div>

<p>This eliminates any need to resolve function overloads entirely since it has no overloads. However, it&rsquo;s pretty ugly in this case where it presents a large amount of visual weight in an otherwise lightweight expression.</p>

<p>A final approach, is that in many cases you can replace free functions and operators with methods:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">).</span><span class="n">negated</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">).</span><span class="n">negated</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.</span><span class="n">negated</span><span class="p">()</span></code></pre></div>

<p>This works because methods normally have fewer overloads than the common arithmetic operators and type inference with the <code>.</code> operator is often narrower than via free functions.</p>

<h2 id="swift-s-constraints-system-solver">Swift&rsquo;s constraints system solver</h2>

<p>The &ldquo;expression was too complex&rdquo; error is emitted by the &ldquo;Sema&rdquo; (semantic analysis) stage in the Swift compiler. Semantic analysis is responsible for resolving types in a system, ensuring that they all agree with each other and building a well-typed expression where all types are explicit.</p>

<p>More specifically, the error is triggered by <a href="https://github.com/apple/swift/blob/master/lib/Sema/CSSolver.cpp">the constraints system solver (CSSolver.cpp)</a> within the semantic analysis stage. The constraints system is a graph of types and functions from a Swift expression and the edges in this graph are constraints between nodes. The constraints system solver processes the constraints from the constraints system graph until an explicit type or function is determined for each node.</p>

<p>All of that is really abstract so let&rsquo;s look at a concrete example.</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span></code></pre></div>

<p>The constraints system representation of this expression looks something like this:</p>

<p><img src="../../../../assets/blog/constraints_graph1.svg" alt="a simple constraints graph" /></p>

<p>The labels starting with &ldquo;T&rdquo; (for &ldquo;type&rdquo;) in the diagram come from the constraints system debug logging and they are used to represent types or function overloads that need to be resolved. In this graph, the nodes have the following constraints:</p>

<ol>
<li>T1 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T2 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T0 is a function that takes (T1, T2) and returns T3</li>
<li>T0 is one of 28 implementations in the Swift standard library named <code>infix +</code></li>
<li>T3 is convertible to T4</li>
</ol>

<blockquote>
<p>NOTE: If you&rsquo;re more familiar with Swift 2 terminology, <code>ExpressibleByIntegerLiteral</code> was previously named <code>IntegerLiteralConvertible</code>.</p>
</blockquote>

<p>To resolve this system, the constraints system solver starts with the &ldquo;smallest disjunction&rdquo;. Disjunctions are constraints that constrain a value to be &ldquo;one of&rdquo; a set (essentially, a logical OR). In this case, there&rsquo;s exactly one disjunction: the T0 function overload in constraint 4. The solver picks the first implementation of <code>infix +</code> in its list: the <code>infix +</code> implementation with type signature <code>(Int, Int) -&gt; Int</code>.</p>

<p>Since this is the only disjunction in the graph, the solver then resolves type constraints. Types T1, T2 and T3 are <code>Int</code> due to constraint 3. T4 is also <code>Int</code> due to constraint 5.</p>

<p>Since T1 and T2 are <code>Int</code> (which is the &ldquo;preferred&rdquo; match for an <code>ExpressibleByIntegerLiteral</code>), no other overloads to the <code>infix +</code> function are considered; the constraints system solver can ignore all other possibilities and use this as the solution. We have explicit types for all nodes and we know the selected overload for each function.</p>

<h2 id="getting-more-complex-quickly">Getting more complex, quickly</h2>

<p>Thus far, there&rsquo;s nothing strange and you might not expect that Swift would start failing with expressions just a few times bigger. But let&rsquo;s make just two changes: wrap the <code>2</code> in parentheses and apply a negation operator (<code>prefix -</code>) and add a type of <code>Double</code> for the result.</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></code></pre></div>

<p>This gives a constraints system graph that looks like this:</p>

<p><img src="../../../../assets/blog/constraints_graph2.svg" alt="a slightly more complex constraints graph" /></p>

<p>with the constraints:</p>

<ol>
<li>T1 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T3 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T2 is a function that takes (T3) and returns T4</li>
<li>T2 is one of 6 implementations in the Swift standard library named <code>prefix -</code></li>
<li>T0 is a function that takes (T1, T4) and returns T5</li>
<li>T0 is one of 28 implementations in the Swift standard library named <code>infix +</code></li>
<li>T5 is convertible to <code>Double</code></li>
</ol>

<p>Just 2 more constraints in the system. Let&rsquo;s look at how the constraints system solver handles this example.</p>

<p>The first step to resolve this system is: choose the smallest disjunction. This time that&rsquo;s constraint 4: &ldquo;T2 is one of 6 implementations in the Swift standard library named <code>prefix -</code>&rdquo;. The solver sets T2 to the overload with signature <code>(Float) -&gt; Float</code>.</p>

<p>The next step is to apply the first step again: choose the next smallest disjunction. That&rsquo;s constraint 6: &ldquo;T0 is one of 28 implementations in the Swift standard library named <code>infix +</code>&rdquo;. The solver sets T0 to the overload with signature <code>(Int, Int) -&gt; Int</code>.</p>

<p>The final step is to use the type constraints to resolve all types.</p>

<p>However, there&rsquo;s a problem: the first choice of <code>(Float) -&gt; Float</code> for T2 and the choice of <code>(Int, Int) -&gt; Int</code> for T0 don&rsquo;t agree with each other so constraint 5 (&ldquo;T0 is a function that takes (T1, T4) and returns T5&rdquo;) fails. This solution is invalid and the solver must backtrack and try the next choice for T0.</p>

<p>Ultimately, the solver will go through <em>all</em> of the implementations of <code>infix +</code> and <em>none</em> will satisfy both constraint 5 and constraint 7 (&ldquo;T5 is convertible to <code>Double</code>&rdquo;).</p>

<p>So the constraints system solver will need to backtrack further and try the next overload for T2, <code>(Double) -&gt; Double</code>. Eventually, this <em>will</em> find a solution in the overloads for T0.</p>

<p>However, since <code>Double</code> is not the <em>preferred</em> match for an <code>ExpressibleByIntegerLiteral</code>, the constraints system solver will need to backtrack and choose the next overload for T2 and run another full search through the possible values for T0.</p>

<p>There are 6 total possibilities for T2 but the final 3 implementations are rejected as an optimization (since they are generic implementations and will therefore never be preferred over the explicit <code>Double</code> solution).</p>

<blockquote>
<p>This specific &ldquo;optimization&rdquo; in the constraints solver is the cause of the quirky overload selection behaviors I showed in the <a href="#unexpected-behaviors">Unexpected behaviors</a> section, above.</p>
</blockquote>

<p>Despite this optimization, we&rsquo;ve already gone from solving the constraints system with our first guess to needing 76 different guesses before reaching a solution. If we had another overloaded function to resolve, the number of guesses would get much, much bigger. For example, if we had another <code>infix +</code> operator in the expression, e.g. <code>let a: Double = 0 + 1 + -(2)</code>, the search space would require 1,190 guesses.</p>

<p>Searching for the solution in this way is a clear case of exponential time complexity. The search space between the disjunction sets here is called a <a href="https://en.wikipedia.org/wiki/Cartesian_product">&ldquo;Cartesian product&rdquo;</a> and for <math><mi>n</mi></math> disjunctions in the graph, this algorithm will search an <math><mi>n</mi></math>-dimensional Cartesian product (an exponential space).</p>

<p>In my testing, 6 disjunctions in a single expression is usually enough to exceed Swift&rsquo;s &ldquo;expression was too complex&rdquo; limits.</p>

<h2 id="linearizing-the-constraints-solver">Linearizing the constraints solver</h2>

<p>A better solution, in the long term, is to fix the problem in the compiler.</p>

<p>The reason why the constraints system solver has an exponential time complexity for resolving function overloads is because (unless it can shortcut around the problem) Swift searches the entire <math><mi>n</mi></math>-dimensional <a href="https://en.wikipedia.org/wiki/Cartesian_product">&ldquo;Cartesian product&rdquo;</a> of all <math><mi>n</mi></math> disjunction sets caused by function overloads in the graph to determine if one of the values is a solution.</p>

<p>To avoid the <math><mi>n</mi></math>-dimensional Cartesian product, we need an approach where disjunctions are solved independently, rather than dependently.</p>

<p>Here is where I need to include a big warning:</p>

<blockquote>
<p><strong>UNPROVEN CLAIMS WARNING</strong>: The following is a <em>theoretical discussion</em> about how I would improve the resolution of function overloads in the Swift constraint system solver. I have not written a prototype to prove my claims. It remains possible that I&rsquo;ve overlooked something that invalidates my reasoning.</p>
</blockquote>

<h3 id="premise">Premise</h3>

<p>We want to satisfy the following two goals:</p>

<ol>
<li>Constraints on a node should not depend upon, or reference, the result from other nodes.</li>
<li>The disjunction from a preceeding function overload should be intersected with the disjunction from a succeeding function, flattening the two constraints to a single disjunction.</li>
</ol>

<p>The first goal can be achieved by propagating constraints along the full path from their origins. Since Swift constraints are bidirectional, the constraint path for each node starts at all of the leaves of the expression, traverses via the trunk and then traverses back along a linear path to the node. By following this path, we can compose constraints that – instead referencing or depending upon types from other nodes – simply incorporate the same constraint logic as other nodes.</p>

<p>The second goal supports the first by reducing the propagated accumulation of constraints down to a single simple constraint. The most important intersection type for function overloads is an intersection of possible outputs from one overloaded function with possible input parameters of another overloaded function. This operation should be calculable by a type check of the intersecting parameter over a 2-dimensional Cartesian product. For other combinations of constraint intersection, a true mathematical intersection might be difficult but it&rsquo;s not necessary to follow strict type rules, we need only reproduce the behavior of Swift&rsquo;s type interference which often resorts to greedy type selection in complicated scenarios.</p>

<h3 id="re-solving-the-previous-example">Re-solving the previous example</h3>

<p>To see how these goals would be used in the constraints system solver, lets revisit the previous constraints graph:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></code></pre></div>

<p><img src="../../../../assets/blog/constraints_graph2.svg" alt="a slightly more complex constraints graph" /></p>

<p>and begin with the same set of constraints:</p>

<ol>
<li>T1 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T3 conforms to <code>ExpressibleByIntegerLiteral</code></li>
<li>T2 is a function that takes (T3) and returns T4</li>
<li>T2 is one of 6 implementations in the Swift standard library named <code>prefix -</code></li>
<li>T0 is a function that takes (T1, T4) and returns T5</li>
<li>T0 is one of 28 implementations in the Swift standard library named <code>infix +</code></li>
<li>T5 is convertible to <code>Double</code></li>
</ol>

<h3 id="propagating-constraints-from-right-to-left">Propagating constraints from right to left</h3>

<p>We start by traversing from right to left (from the leaves of the expression tree down to the trunk).</p>

<p>Propagating the constraint on T3 to T2 adds the constraint &ldquo;T2&rsquo;s input must be convertible from a type that is <code>ExpressibleByIntegerLiteral</code> with <code>Int</code> preferred due to literal rules&rdquo;. Intersecting this new constraint with the existing T2 constraints, discards the new constraint since all input parameters in T2&rsquo;s existing possibility space already fulfill this new constraint and the preference of <code>ExpressibleByIntegerLiteral</code> for <code>Int</code> type on the input is overruled by the preference for specific operator overloads over generic operator overloads (which makes <code>Double</code>, <code>Float</code> or <code>Float80</code> overloads of the <code>prefix -</code> function preferred). Propagating T2 to T4 adds the constraint &ldquo;T4 must be one of the 6 types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred&rdquo;. Propagating T4 to T0 adds the constraint &ldquo;T0&rsquo;s second parameter must be convertible from one of the 6 types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred&rdquo;. Intersecting this with the constraints already on T0 leaves the constraint &ldquo;T0 is one of 6 implementations in the Swift standard library named <code>infix +</code> where the right input is one of the types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred&rdquo;. Propagating T1 to T0 has no additional effect (since all choices in the existing constraint on T0 already fulfill this new constraint and the preference of <code>ExpressibleByIntegerLiteral</code> for <code>Int</code> type is cancelled out by the preference for <code>Double</code>, <code>Float</code> or <code>Float80</code>). Propagating T0 to T5 add the constraint &ldquo;T5 is one of 6 values returned from the <code>infix +</code> operator where the second parameter is one of the types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred&rdquo;. Intersecting this with the constraint already on T5 leaves &ldquo;T5 is <code>Double</code>&rdquo;.</p>

<p>The half-propagated constraints are now:</p>

<ol>
<li>T1 conforms to <code>ExpressibleByIntegerLiteral</code> with <code>Int</code> preferred due to literal rules</li>
<li>T3 conforms to <code>ExpressibleByIntegerLiteral</code> with <code>Int</code> preferred due to literal rules</li>
<li>T2 is a function that takes (T3) and returns T4</li>
<li>T2 is one of 6 implementations in the Swift standard library named <code>prefix -</code> with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred due to the preference for specific operator overloads over generic operator overloads</li>
<li>T4 must be one of the 6 types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> or <code>Float80</code> preferred due to the preference for specific operator overloads over generic operator overloads</li>
<li>T0 is a function that takes (T1, T4) and returns T5</li>
<li>T0 is one of the 6 implementations in the Swift standard library named <code>infix +</code> where the second parameter is one of the 6 types output from <code>prefix -</code>, with <code>Double</code>, <code>Float</code> and <code>Float80</code> preferred due to the preference for specific operator overloads over generic operator overloads</li>
<li>T5 is <code>Double</code></li>
</ol>

<h3 id="propagating-constraints-from-left-to-right">Propagating constraints from left to right</h3>

<p>Now we go left to right (from the trunk, up to the leaves).</p>

<p>Starting at the constraints on T5. Constraint 5 is &ldquo;T5 is <code>Double</code>&rdquo;. Propagating this to T0 creates a new constraint on T0 that its result must be convertible to <code>Double</code>. The intersection of this new constraint and the result of T0 immediately eliminates all possible overloads for the <code>infix +</code> operator except <code>(Double, Double) -&gt; Double</code>. Propagating from T0 to T1, via the first parameter of this overload, creates a new constraint for T1  that it must convertible to <code>Double</code>. Intersecting this new constraint with the previous &ldquo;T1 conforms to <code>ExpressibleByIntegerLiteral</code>&rdquo; results in &ldquo;T1 is <code>Double</code>&rdquo;. Propagating from T0 to T4, via the second parameter of the selected <code>infix +</code> overload creates a new constraint for T4 that it must be convertible to <code>Double</code>. Intersecting this new constraint with the existing constraint on T4 results in &ldquo;T4 is <code>Double</code>&rdquo;. Propagating from T4 to T2 creates a new constraint on T2 that it must return a type that is convertible to <code>Double</code>. Intersecting this new constraint with the previous constraints on T2 immediately eliminates all overloads except <code>(Double) -&gt; Double</code>. Propagating from T2 to T3 creates a new constraint for T3 that it must convertible to <code>Double</code>. Intersecting this new constraint with the previous &ldquo;T3 conforms to <code>ExpressibleByIntegerLiteral</code>&rdquo; results in &ldquo;T3 is <code>Double</code>&rdquo;.</p>

<p>The fully-propagated constraints are now:</p>

<ol>
<li>T1 is <code>Double</code></li>
<li>T3 is <code>Double</code></li>
<li>T2 is the <code>(Double) -&gt; Double</code> overload of <code>prefix -</code></li>
<li>T0 is the <code>(Double, Double) -&gt; Double</code> overload of <code>infix +</code></li>
<li>T5 is <code>Double</code></li>
</ol>

<p>And the constraints system is solved.</p>

<h2 id="how-would-performance-compare">How would performance compare?</h2>

<p>The purpose of my suggested algorithm is to improve the resolution of function overloads, so I&rsquo;ll call the number of function overloads <math><mi>n</mi></math>. I&rsquo;ll use <math><mi>m</mi></math> for the average number of overloads per function (the &ldquo;disjunction&rdquo; size).</p>

<p>As I previously stated, Swift&rsquo;s algorithm solves this by searching an <math><mi>n</mi></math>-dimensional Cartesian product of rank <math><mi>m</mi></math>. This gives is an upper bound of <math><mi>O</mi><mo>(</mo><msup><mi>m</mi><mrow><mi>n</mi></mrow></msup><mo>)</mo></math> which is an exponential time complexity.</p>

<p>My suggested algorithm resolves <math><mi>n</mi></math> function overloads by searching <math><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo></math> separate 2-dimensional Cartesian products of rank <math><mi>m</mi></math>. This gives is an execution time proportional to <math><msup><mi>m</mi><mrow><mn>2</mn></mrow></msup><mi>n</mi></math>. Assuming <math><mi>m</mi></math> is independent of <math><mi>n</mi></math> (true when we can calculate the intersection between constraints, false otherwise), this makes the upper bound <math><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></math>, linear time complexity.</p>

<p>Linear complexity will always beat exponential complexity for large values of <math><mi>n</mi></math> but it&rsquo;s important to know what constitutes &ldquo;large&rdquo; and what effect other factors might have for smaller values. In this case, 3 is already a &ldquo;large&rdquo; value. As I previously stated, Swift&rsquo;s constraint system solver would require 1,190 guesses to solve the expression <code>let a: Double = 0 + 1 + -(2)</code>. My suggested algorithm would require a search of just 336 possibilities and would have significantly lower overheads per possibility than Swift&rsquo;s current approach.</p>

<p>I&rsquo;m making an interesting assertion there: I&rsquo;m claiming that my suggested algorithm would have lower overheads per possible solution. Let&rsquo;s look at that in more detail for <math><mi>n</mi><mo>=</mo><mn>2</mn></math> with our previous <code>let a: Double = 1 + -(2)</code> example. Theoretically, both Swift&rsquo;s algorithm and my suggested algorithm will search the same 2-dimensional Cartesian product between <code>prefix -</code> and <code>infix +</code> – a space that contains 168 possible solutions.</p>

<p>Swift&rsquo;s current algorithm searches just 76 possible entries out of a total possible 168 in the 2-dimensional Cartesian product space between the overloads of <code>prefix -</code> and <code>infix +</code>. But in doing so, Swift&rsquo;s algorithm performs 567 calls to <code>ConstraintSystem::matchTypes</code>, of which 546 are related solely to function overload guesses. Swift performs a large number of type checks per guess.</p>

<p>My suggested algorithm would search the entire 168 possible entries in the 2-dimensional Cartesian product space (I haven&rsquo;t included any shortcuts or optimizations at this point) but since it only checks the <em>intersecting</em> parameters at each search location (it doesn&rsquo;t check unrelated type constraints), I estimate that it would require just 222 total calls to <code>ConstraintSystem::matchTypes</code> for the entire solution.</p>

<p>Determining performance for an unwritten algorithm involves a lot of guesswork, so it&rsquo;s difficult to know with any degree of certainty, but it&rsquo;s possible that my algorithm would perform equal or better for <em>any</em> value of <math><mi>n</mi></math>.</p>

<h2 id="update-limitations">Update: limitations</h2>

<blockquote>
<p>Thanks to Jordan Rose from the Swift team at Apple for <a href="https://twitter.com/uint_min/status/866333216885448704">prompting me</a> to take a look at <a href="https://blogs.msdn.microsoft.com/ericlippert/2007/03/28/lambda-expressions-vs-anonymous-methods-part-five/">an article I hadn&rsquo;t previously read</a> looking at the worst-case complexity of overload resolution.</p>
</blockquote>

<p>As I write this update in May 2017, this article is nearly a year old. Swift&rsquo;s type checker has seen a number of special-case improvements (see the Swift 3.1 updates throughout this article) but the core hasn&rsquo;t changed dramatically and it would still benefit from an approach that is linear&hellip;</p>

<p>&hellip;in most cases.</p>

<p>There are two particular conditions that can combine together to make the problem space truly exponential complexity in which case my suggestions for linearizing would have no benefit.</p>

<h3 id="conditions-preventing-linearization">Conditions preventing linearization</h3>

<p>It my be impossible to linearize the constraints solve if one or both of the following conditions are true:</p>

<ol>
<li>Overloaded functions exist such that knowing constraints on any input parameter or the return does not narrow the possible overloads in a way that you can apply constraints to other parameters or the return.</li>
<li>Variables in otherwise unrelated branches of the expression tree are constrained to be the same type
<br /></li>
</ol>

<h3 id="explanation-of-the-first-condition">Explanation of the first condition</h3>

<p>An example of the first condition is a function with the following overloads:</p>

<ul>
<li><code>X(F,F,F) -&gt; F</code></li>
<li><code>X(F,F,T) -&gt; F</code></li>
<li><code>X(F,T,F) -&gt; T</code></li>
<li><code>X(F,T,T) -&gt; T</code></li>
<li><code>X(T,F,F) -&gt; T</code></li>
<li><code>X(T,F,T) -&gt; T</code></li>
<li><code>X(T,T,F) -&gt; F</code></li>
<li><code>X(T,T,T) -&gt; F</code></li>
</ul>

<p>Independently knowing the type of any parameter or the return value for this function does not narrow the possible set of overloads enough for us to add new constraints to the other parameters or return value. Unless you know at least 2 parameters simultaneously, the remaining parameters are completely unconstrained.</p>

<h3 id="explanation-of-the-second-condition">Explanation of the second condition</h3>

<p>The second point is a bit more complicated and I didn&rsquo;t pay attention to the possibility in Swift until I read an article on a similar problem in C#: <a href="https://blogs.msdn.microsoft.com/ericlippert/2007/03/28/lambda-expressions-vs-anonymous-methods-part-five/">Lambda Expressions vs. Anonymous Methods, Part Five</a>.</p>

<p>When you&rsquo;re using closures, the closure parameters might not be fully resolved yet they have names which can be used at multiple points inside the closure. Using these unresolved names makes separate branches of the expression constrained to be type and yet forced to adhere to the constraints for each, separate location.</p>

<p>An example is:</p>

<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="p">{</span> <span class="n">t</span> <span class="k">in</span> <span class="cm">/*...*/</span> <span class="p">}(</span><span class="n">manyOverloads</span><span class="p">())</span></code></pre></div>

<p>Any use of <code>t</code> in the closure must have the same type as every other use of <code>t</code> but that type is unknown (could be any of the return values from <code>manyOverloads</code>) so the selected overload to use for <code>manyOverloads</code> must adhere to every constraint at every separate location in the closure.</p>

<h3 id="consequences">Consequences</h3>

<p>When the first of these conditions is true, my brief pen-and-paper estimate is that the system may increase from linear complexity to logarithmic complexity; this isn&rsquo;t a serious problem. When the second of these conditions is true, depending on the kinds of constraints involved, a linear solution might remain possible or the intersection of constraints could lead to quadratic complexity; bad but far from catastrophic.</p>

<p>When both of these conditions is true, the problem of choosing function overloads is equivalent to the Boolean Satisfiability Problem (SAT) and is at least as hard as 3-SAT. This means the problem is NP-Complete and all known solutions are exponential complexity.</p>

<p>So what does this mean?</p>

<p>Linearization should still be possible in a vast majority of cases. These two conditions are fairly uncommon – although not unknown. There are a handful of closures in this article that demonstrate the second condition. I don&rsquo;t believe any of these closures would lead to an increase in complexity beyond linear (since they occur in situations of easy-to-intersect constraints) but it highlights that this condition does occur.</p>

<p>The first condition is actually the rarer of the two. I can&rsquo;t personally think of a situation where a function with overloads like this might occur outside of mathematics functions that offer implicit type conversion (a pattern that is frowned upon in Swift). However, it&rsquo;s worth keeping in mind how hard this kind of blindly overloaded function is on a constraints solver – definitely a design pattern to avoid.</p>

<p>Ultimately, the cases where this type of SAT complexity apply should be extremely rare and programmatically detectable. Once detected, you could even make this type of expression a compiler warning (it would be easy to design around or at least decorate the closure parameter types).</p>

<h2 id="conclusion">Conclusion</h2>

<p>In my usage of Swift, the &ldquo;expression was too complex to be solved in reasonable time&rdquo; error is the most common error I see that isn&rsquo;t a simple programmer error. If you write a lot of large functional-style expressions or mathematics code, you&rsquo;ll likely see it on a regular basis.</p>

<p>The exponential time complexity in the Swift compiler&rsquo;s constraints system solver can also lead to significant compilation time overhead. While I don&rsquo;t have numbers on what percentage of typical Swift compilation times are spent in this part of the compiler, there are certainly degenerate cases where the <em>majority</em> of a long compilation time is spent in the constraints system solver.</p>

<p>The problem can be worked around in our own code but outside of cases that deliberately emulate the Boolean Satisfiability Problem, it shouldn&rsquo;t be necessary. I&rsquo;m fairly sure linear time evaluation is possible in a vast majority of cases that are currently problematic and I&rsquo;ve laid out a way I think it could be done.</p>

		</div>
	</article>
</main>

<div class="pagination">
  <div class="page-prev">
    Previous article:<br/><a href="../../06/25/policing-whitespace.html">Parsing whitespace in an Xcode extension</a>
  </div>
  <div class="page-next">
    Next article:<br/><a href="../30/timer-problems.html">Design patterns for safe timer usage</a>
  </div>
</div>


</div>
</div>

<footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Subscribe: <a href="../../../../feed.json">JSON</a>, <a href="../../../../feed.xml.rss">RSS</a> or <a href="https://apple.news/ToAaeVKb9TJOyYZi4sXnvXg">Apple News</a></li>
          <li>Twitter: <a href="https://twitter.com/cocoawithlove">@cocoawithlove</a></li>
          <li>Github: <a href="https://github.com/mattgallagher">mattgallagher</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>&copy; 2008-2017 Matt Gallagher. All rights reserved.<br/>Code may be used in accordance with license on <a href="../../../../about/index.html">About</a> page.<br/>If you need to contact me: <script type="text/javascript">
e1=('cocoa' + 'with' + 'love' + '&#46' + 'com')
e2=('info' + '&#64')
document.write('<a href="mailto:' + e2 + e1 + '">' + e2 + e1 + '</a>')
</script></p>
      </div>
    </div>

  </div>

</footer>

</body>

</html>
