<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>A view construction syntax</title>
  <meta name="description" content="In this article, I look at constructing Cocoa views in code using a unique syntax that offers dynamic and constant options with no syntactic overhead, support for parameters inherited through the class hierarchy, support for large numbers of optional parameters without needing to push unused parameters onto the stack, avoidance of parentheses, and avoiding the need to specify types – all while remaining completely typesafe." />

  <meta name="twitter:title" content="A view construction syntax"/>
  <meta name="twitter:image" content="https://www.cocoawithlove.com/assets/site/touch_heartandcup.png"/>
  <meta name="twitter:url" content="https://www.cocoawithlove.com/blog/a-view-construction-syntax.html"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:description" content="In this article, I look at constructing Cocoa views in code using a unique syntax that offers dynamic and constant options with no syntactic overhead, support for parameters inherited through the class hierarchy, support for large numbers of optional parameters without needing to push unused parameters onto the stack, avoidance of parentheses, and avoiding the need to specify types – all while remaining completely typesafe."/>

  <link rel="icon" href="../assets/site/heartandcup.png" />
  <link rel="apple-touch-icon" href="../assets/site/touch_heartandcup.png" />
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="canonical" href="a-view-construction-syntax.html" />

  
</head>

<body>

<div class="hidetopextension"></div>
<header class="nav-header">
  <div class="wrapper">
  	<a href="../index.html"><img class="heartandcup" src="../assets/site/heartandcup.svg"></a>
  	<a class="top" href="#">top</a>
    <nav class="site-nav" onClick="if (this.className == 'site-nav') { this.className = 'site-nav-collapsed'; } else { this.className = 'site-nav'; }">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="../about/index.html">about</a>
        <a class="page-link" href="../archive/index.html">archive</a>
        <a class="page-link" href="../search/index.html">search</a>
        <a class="page-link" href="http://zqueue.com/">zqueue.com</a>
      </div>
    </nav>
  </div>
</header>

<div class="nav-header-baseline"></div>

<div class="wrapper"><div class="hidetop"></div></div>

<header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="../index.html">
      <img class="site-banner" alt="Matt Gallagher: Cocoa with Love" src="../assets/site/banner.svg" width="720px" height="135px">
    </a>
  </div>
</header>

<div class="banner-baseline"></div>

<div class="page-content">
<div class="wrapper">


<header class="post-header">
	<h1 class="post-title" itemprop="headline">A view construction syntax</h1>
	<div class="post-meta"><time itemprop="datePublished" datetime="2017-12-15">December 15, 2017</time> by Matt Gallagher</div>
	<div class="post-tags">Tags:
		
			<a href="../tags/cocoa.html">cocoa</a>, <a href="../tags/swift.html">swift</a>, <a href="../tags/views.html">views</a>
		 
	</div>
</header>


<main role="main">
	<article itemscope itemtype="http://schema.org/BlogPosting">
		<div class="post-content" itemprop="articleBody">
			

<p>In this article, I&rsquo;m going to look at constructing Cocoa views in code.</p>

<p>On its own, that&rsquo;s not a particularly daring idea but I&rsquo;m going to use a unique syntax to aid the process:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">text</span> <span class="o">--</span> <span class="n">model</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">enabled</span> <span class="o">--</span> <span class="kc">true</span>
<span class="p">)</span></code></pre></div>
<p>This code trades conventional <code>parameter: value</code> syntax for a custom <code>.parameter -- value</code> syntax and uses this change to offer a few advantages: dynamic and constant options with no syntactic overhead, support for parameters inherited through the class hierarchy, support for large numbers of optional parameters without needing to push unused parameters onto the stack, avoidance of parentheses, and avoiding the need to specify types – all while remaining completely typesafe.</p>

<p>I&rsquo;ll be looking at how this syntax is implemented and the various tricks it uses to make the Swift type system do all the menial work.</p>

<blockquote>
<p>This article is a sneak peek at one of the key ideas in an upcoming library named CwlViews that should be available soon. A <a href="https://github.com/mattgallagher/CocoaWithLovePlaygrounds">ViewConstruction.playground is available right now</a>, so you can play with the examples presented in this article.</p>
</blockquote>

<nav id="TableOfContents"><span class="toc-heading">Contents</span>
<ul>
<li>
<ul>
<li><a href="#aim">Aim</a></li>
<li><a href="#interface-builder">Interface Builder?</a></li>
<li><a href="#construction-in-normal-cocoa-code">Construction in normal Cocoa code</a></li>
<li><a href="#reactive-programming">Reactive programming</a></li>
<li><a href="#everything-in-a-single-expression">Everything in a single expression</a></li>
<li><a href="#enum-cases-as-parameter-names">Enum cases as parameter names</a></li>
<li><a href="#enums-with-inheritance">Enums with inheritance</a></li>
<li><a href="#dynamic-values">Dynamic values</a></li>
<li><a href="#hiding-dirty-work-in-the-type-system">Hiding dirty work in the type system</a></li>
<li><a href="#intermediate-type">Intermediate type</a></li>
<li><a href="#a-little-operator-overloading">A little operator overloading</a></li>
<li><a href="#alternatives">Alternatives</a></li>
<li><a href="#drawbacks">Drawbacks</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#looking-forward">Looking forward</a></li>
</ul></li>
</ul></li>
</ul>
</nav>

<h2 id="aim">Aim</h2>

<p>In an app wireframe (a rough layout of a user-interface provided by the graphic artist or user-experience designer), a <code>UITextField</code> might be appear as a simple box. The wireframe usually gives (or implies) the layout constraints required for the text field but otherwise might not offer any information about the <em>behaviors</em> of the text field.</p>

<p>When implementing user interfaces, before I start coding, I normally go through the wireframes and break down each element of the user interface with descriptions that look like this:</p>

<pre><code>nameField: UITextField
   - borderStyle: `.roundRect`
   - isEnabled:
      `true` if `personViewState.isEditing` is `true`, otherwise `false`
   - backgroundColor:
      `.white` while `personViewState.isEditing` is `true`, otherwise `.lightGray`
   - text:
      - `name` value of `Person` object in `Document` where `id`==`personViewState.id`
   - on UITextFieldDidChange:
      - set `name` value of `Person` object in `Document` where
        `id`==`personViewState.id` to the value of `text`
</code></pre>

<p>I write this type of description because it&rsquo;s how I mentally consider the properties of the view. It&rsquo;s really just a list of view properties and the behaviors I want them to have. Structurally, it resembles a property list, similar to YAML or other text-based property formats. The precise syntax involved isn&rsquo;t as important as the relatively simple structure.</p>

<p>Ideally, I would like my view construction code to look as close to this description as possible.</p>

<p>As we&rsquo;ll see though, typical Cocoa view construction code looks <em>nothing</em> like this.</p>

<h2 id="interface-builder">Interface Builder?</h2>

<p>This article is about building views in code. It&rsquo;s worth briefly discussing <em>why</em> we would construct in Swift code, given that Apple promote construction via Interface Builder as a first choice.</p>

<p>The original idea behind Interface Builder was to offer a &ldquo;what-you-see-is-what-you-get&rdquo; editor for pixel-based layout of fixed sized windows and dialogs. The original Interface Builder ran the program, live – so it actually was WYSIWYG – and fixed size windows were the norm. None of this has been true for years.</p>

<p>Instead, the common uses for Interface Builder are:</p>

<ol>
<li>configuring auto-layout constraints</li>
<li>setting values for <em>some</em> (but not all) constant properties in Interface Builder</li>
<li>defining segues</li>
<li>supporting Storyboard-based view-state restoration</li>
</ol>

<p>For a range of reasons though, none of these are valuable to me.</p>

<p>On the first point: I find using specifying individual constraints in Interface Builder is laborious and frustrating. As I mentioned in <a href="cwllayout.html">CwlLayout: a Swift wrapper around Auto Layout</a>, I prefer to specify layout by <em>intent</em> and let the framework handle specific constraints (as with <code>UIStackView</code> or my own CwlLayout).</p>

<p>On the second point: the difficult properties to handle are the <em>dynamic</em> properties but Interface Builder helps only with constant properties. Even with constant properties, as my apps grow, I usually end up with pre-prepared sets of properties – &ldquo;Styles&rdquo; – for the views in my app and you can&rsquo;t really do this in Interface Builder, either.</p>

<p>On the third point: I <em>strongly</em> dislike how data is propagated during segues, requiring cooperation between  <code>perform(segue:)</code> and <code>prepare(for:)</code> and needing one <code>UIViewController</code> to push key data to another <code>UIViewController</code> <em>after</em> construction. This might seem like empty complaining but with data dependencies and data propagation being the single most important pipeline in an application, actively promoting bad practices like cooperative coupling and side-effects is a show stopping issue. Accordingly, I tend not to use segues, in favor of manual <code>UIViewController</code> construction and transitions.</p>

<p>On the fourth point: if you use a persistent view-state approach, like the <a href="view-state-driven-applications.html">Model-View-Controller + ViewState approach I showed in the previous article</a>, state restoration is already a part of the process, without needing Storyboards or restoration identifiers. So I don&rsquo;t use Storyboard state restoration.</p>

<p>Like most long-term Cocoa programmers, I&rsquo;ve gone back-and-forth about how much or little to use Interface Builder in my projects. Interface Builder has always been a core component of Cocoa development, as it was a core component of NeXTStep and <a href="https://vimeo.com/62618532">ExperLISP before that</a>. Writing Cocoa &ldquo;properly&rdquo; has generally involved using Interface Builder in some capacity.</p>

<p>For the last few years though, the only argument in favor of Interface Builder has been that constructing Cocoa views in Objective-C/Swift is ugly. It&rsquo;s not technically difficult to construct one or two views in code but the construction involves multiple statements without any obvious structure and as you add more views, the lack of structure leads to messy, hard to read code.</p>

<p>The purpose of this article is to talk about the process I&rsquo;ve gone through, trying to building views in Swift code using a clear, structured syntax so it might be a manageable alternative to Interface Builder.</p>

<h2 id="construction-in-normal-cocoa-code">Construction in normal Cocoa code</h2>

<p>Nearly every view can be default constructed:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">()</span></code></pre></div>
<p>It&rsquo;s a zero sized view with no contents and a transparent background – not that you&rsquo;d notice at this point, since it&rsquo;s a zero sized view.</p>

<p>Let&rsquo;s set some simple values on this text field so that we can see it:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">nameField</span> <span class="p">=</span> <span class="n">UITextField</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">80</span><span class="p">))</span>
<span class="n">nameField</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">someTextValue</span>
<span class="n">nameField</span><span class="p">.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="kc">false</span>
<span class="n">nameField</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">white</span></code></pre></div>
<p>Immediately, you can see an inconsistency: some properties can be set through the constructor (in the case of a <code>UITextField</code>, the <code>frame</code>) but most properties require separate steps.</p>

<p>The fact that the <code>frame</code> can be set in the <code>UIView</code> constructor might make this property appear important but its presence is an anachronism. In an auto-layout world, setting the <code>frame</code> is completely useless – layout constraints will totally override any value we set here. We might as well stick with the default constructor.</p>

<p>Setting the other properties isn&rsquo;t much more helpful. In my description of the <code>UITextField</code>, all of these properties are supposed to be <em>dynamic</em> which means that they have a data dependency on another value elsewhere in the program. Setting them here in isolation – without a connection to their data dependency – is dangerous; it can make them look as though they&rsquo;ve been correctly configured when they are not.</p>

<p>It&rsquo;s far better to handle dynamic properties when we set up our connection to the data dependency. We should use some form of observing that guarantees to immediately provide the initial value. In the previous article, I used an <code>addObserver</code> wrapper around <code>NotificationCenter.addObserver</code>  that guaranteed this.</p>

<p>Let&rsquo;s properly construct the <code>UITextField</code> with all of the requirements specified in my text description in the &ldquo;Aim&rdquo; section.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">var</span> <span class="nv">nameField</span><span class="p">:</span> <span class="n">UITextField</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">personViewState</span><span class="p">:</span> <span class="n">PersonViewState</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">person</span><span class="p">:</span> <span class="n">Person</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">observations</span><span class="p">:</span> <span class="p">[</span><span class="nb">NSObjectProtocol</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>

<span class="kr">override</span> <span class="n">loadView</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">field</span> <span class="p">=</span> <span class="n">UITextField</span><span class="p">()</span>
   <span class="kc">self</span><span class="p">.</span><span class="n">nameField</span> <span class="p">=</span> <span class="n">field</span>

   <span class="c1">// Constant properties</span>
   <span class="n">field</span><span class="p">.</span><span class="n">borderStyle</span> <span class="p">=</span> <span class="p">.</span><span class="n">roundedRect</span>
   
   <span class="c1">// Dynamic properties</span>
   <span class="n">observations</span> <span class="o">+=</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">addObserver</span> <span class="p">{</span> <span class="p">[</span><span class="kr">weak</span> <span class="kc">self</span><span class="p">]</span> <span class="n">state</span> <span class="k">in</span>
      <span class="k">guard</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="kc">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
      <span class="n">s</span><span class="p">.</span><span class="n">personViewState</span> <span class="p">=</span> <span class="n">state</span><span class="p">.</span><span class="n">personViewState</span>
      <span class="n">s</span><span class="p">.</span><span class="n">nameField</span><span class="p">?.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="n">state</span><span class="p">.</span><span class="n">personViewState</span><span class="p">.</span><span class="n">isEditing</span>
      <span class="n">s</span><span class="p">.</span><span class="n">nameField</span><span class="p">?.</span><span class="n">backgroundColor</span> <span class="p">=</span>
         <span class="n">state</span><span class="p">.</span><span class="n">personViewState</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span>
      <span class="k">if</span> <span class="n">s</span><span class="p">.</span><span class="n">person</span><span class="p">?.</span><span class="n">id</span> <span class="o">!=</span> <span class="n">state</span><span class="p">.</span><span class="n">personViewState</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
         <span class="kd">let</span> <span class="nv">person</span> <span class="p">=</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">person</span><span class="p">(</span><span class="n">forId</span><span class="p">:</span> <span class="n">state</span><span class="p">.</span><span class="n">personViewState</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">s</span><span class="p">.</span><span class="n">updatePerson</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">observations</span> <span class="o">+=</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">addObserver</span> <span class="p">{</span> <span class="p">[</span><span class="kr">weak</span> <span class="kc">self</span><span class="p">]</span> <span class="n">document</span> <span class="k">in</span>
      <span class="k">guard</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="kc">self</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">id</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">personViewState</span><span class="p">?.</span><span class="n">id</span><span class="p">,</span>
         <span class="kd">let</span> <span class="nv">person</span> <span class="p">=</span> <span class="n">document</span><span class="p">.</span><span class="n">person</span><span class="p">(</span><span class="n">forId</span><span class="p">:</span> <span class="n">id</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
      <span class="n">s</span><span class="p">.</span><span class="n">updatePerson</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="c1">// Actions</span>
   <span class="kd">let</span> <span class="nv">o</span> <span class="p">=</span> <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">forName</span><span class="p">:</span> <span class="p">.</span><span class="n">UITextFieldDidChange</span><span class="p">,</span>
      <span class="n">object</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span> <span class="n">queue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="kr">weak</span> <span class="kc">self</span><span class="p">]</span> <span class="n">n</span> <span class="k">in</span>
      <span class="k">guard</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="kc">self</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">text</span> <span class="p">=</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">UITextField</span><span class="p">)?.</span><span class="n">text</span><span class="p">,</span>
         <span class="kd">let</span> <span class="nv">pvs</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">personViewState</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
      <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">forPersonId</span><span class="p">:</span> <span class="n">pvs</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="n">observations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">updatePerson</span><span class="p">(</span><span class="kc">_</span> <span class="n">person</span><span class="p">:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
   <span class="kc">self</span><span class="p">.</span><span class="n">person</span> <span class="p">=</span> <span class="n">person</span>
   <span class="n">nameField</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">name</span>
<span class="p">}</span></code></pre></div>
<p>Ouch! That&rsquo;s gigantic! What happened?</p>

<p>Even <em>with</em> a wrapper around <code>NotificationCenter.addObserver</code> to make it more syntactically efficient, my eleven line text description has turned into 30+ lines of multi-structured, visually complex code. The actual properties we&rsquo;re manipulating are lost in the middle somewhere.</p>

<p>There&rsquo;s a number of reasons why the code is verbose and complex. The biggest problems are the cross dependency between the <code>Person</code> model object and the <code>PersonViewState</code> (because we want to observe the <code>Person</code> identified by the <code>id</code> on the view&rsquo;s <code>PersonViewState</code>), the clumsy need to observe the <code>.UITextFieldDidChange</code> notification to get the text changes and the continual need to use <code>weak self</code> and other quirks associated with callbacks from a child object needing to access data and methods on the parent view controller.</p>

<h2 id="reactive-programming">Reactive programming</h2>

<p><a href="reactive-programming-what-and-why.html">I&rsquo;ve previously shown how reactive programming can be used to simplify observing code</a>. By taking advantage of the <code>flatMapLatest</code> operator (which starts a new observation when its input changes) and some other mapping and combining functions, we can dramatically simplify these dependent observations:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">var</span> <span class="nv">endpoints</span><span class="p">:</span> <span class="p">[</span><span class="n">Cancellable</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>

<span class="kd">func</span> <span class="nf">constructTextField</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">field</span> <span class="p">=</span> <span class="n">UITextField</span><span class="p">()</span>
   <span class="kc">self</span><span class="p">.</span><span class="n">nameField</span> <span class="p">=</span> <span class="n">field</span>
   
   <span class="c1">// Constant properties</span>
   <span class="n">field</span><span class="p">.</span><span class="n">borderStyle</span> <span class="p">=</span> <span class="p">.</span><span class="n">roundedRect</span>
   
   <span class="c1">// Dynamic properties</span>
   <span class="kc">self</span><span class="p">.</span><span class="n">endpoints</span> <span class="o">+=</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span><span class="p">.</span><span class="n">subscribeValues</span> <span class="p">{</span> <span class="n">state</span> <span class="k">in</span>
      <span class="n">field</span><span class="p">.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="n">state</span><span class="p">.</span><span class="n">isEditing</span>
      <span class="n">field</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">state</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span>
   <span class="p">}</span>
   <span class="kc">self</span><span class="p">.</span><span class="n">endpoints</span> <span class="o">+=</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">subscribeValues</span> <span class="p">{</span> <span class="n">field</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="nv">$0</span> <span class="p">}</span>
   
   <span class="c1">// Actions</span>
   <span class="n">signalFromNotifications</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="p">.</span><span class="n">UITextFielddidChange</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">field</span><span class="p">)</span>
      <span class="p">.</span><span class="n">filterMap</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">UITextField</span><span class="p">)?.</span><span class="n">text</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">triggerCombine</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span><span class="p">)</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="n">trigger</span><span class="p">,</span> <span class="nv">$0</span><span class="p">.</span><span class="n">sample</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>This is much better: half the size of the previous example and eliminating some of the quirks like the need for <code>weak self</code> in the observing closures. Most importantly for clarity and maintenance: with the data dependencies combined cleanly, each <code>UITextField</code> property is updated on just a single path.</p>

<p>But it&rsquo;s still 5 separate statements to properly define a single <code>UITextField</code> and you need to look closely to see that this code exists to configure the <code>nameField</code> since the references to this view are buried deep inside the <code>subscribeValues</code> closures.</p>

<p>It&rsquo;s also pretty strange to require an <code>endpoints</code> property (for maintaining the lifetime of the <code>subscribeValues</code> observing) on the <code>UIViewController</code>. This effectively makes the <code>UIViewController</code>, not the <code>UITextField</code>, the observer of the changes. It would be better if the <code>UITextField</code> were the owner of its own reactive lifetimes.</p>

<p>Extending <code>UITextField</code> so that it exposes a signal input and output for each settable property and observable action – a common approach in reactive programming frameworks like ReactiveCocoa or RxCocoa – would eliminate another line or two but wouldn&rsquo;t otherwise improve the structure of the code: it would still require <code>disposables</code> to be held by the <code>UIViewController</code>, would still require a handful of separate statements to fully describe a single view and would still hide the affected view and properties deep inside larger expressions.</p>

<p>I want everything to be a single, self-contained expression where the <code>UITextField</code> manages its own behaviors, rather than requiring another object to facilitate.</p>

<h2 id="everything-in-a-single-expression">Everything in a single expression</h2>

<p>For a moment, let&rsquo;s set aside the difficulties of dynamic properties and output actions. We&rsquo;ll come back to them later.</p>

<p>It is very simple to write a <em>specialized</em> constructor to configure the <code>UITextField</code> properties that we care about in a single expression:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="n">borderStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">roundedRect</span><span class="p">,</span>
   <span class="n">text</span><span class="p">:</span> <span class="n">someTextValue</span><span class="p">,</span>
   <span class="n">isEnabled</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
   <span class="n">backgroundColor</span><span class="p">:</span> <span class="p">.</span><span class="n">white</span><span class="p">,</span>
   <span class="n">textChanged</span><span class="p">:</span> <span class="n">someSignalInput</span>
<span class="p">)</span></code></pre></div>
<p>The real question is: can we use this approach to solve the <em>general</em> case, not just a specialized case?</p>

<p>We could write an <code>init</code> function that had parameters for <em>every</em> possible property and offered default values for each parameter, so we could specify only those parameters for which we want non-default values. For a basic <code>UIView</code> – considering only those properties on <code>UIView</code> itself – there&rsquo;s about 25 properties that you might want to set on construction.</p>

<p>Here&rsquo;s how an <code>init</code> function with all of these parameters might look:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">UIView</span> <span class="p">{</span>
   <span class="kd">init</span><span class="p">(</span>
      <span class="n">alpha</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">backgroundColor</span><span class="p">:</span> <span class="n">UIColor</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span>
      <span class="n">clearsContextBeforeDrawing</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span>
      <span class="n">clipsToBounds</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span>
      <span class="n">contentMode</span><span class="p">:</span> <span class="n">UIViewContentMode</span> <span class="p">=</span> <span class="p">.</span><span class="n">center</span><span class="p">,</span>
      <span class="n">exclusiveTouch</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span>
      <span class="n">gestureRecognizers</span><span class="p">:</span> <span class="p">[</span><span class="n">UIGestureRecognizer</span><span class="p">]</span> <span class="p">=</span> <span class="p">[],</span>
      <span class="n">horizontalContentCompressionResistancePriority</span><span class="p">:</span> <span class="n">UILayoutPriority</span> <span class="p">=</span> <span class="p">.</span> <span class="n">defaultHigh</span><span class="p">,</span>
      <span class="n">horizontalContentHuggingPriority</span><span class="p">:</span> <span class="n">UILayoutPriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">defaultLow</span><span class="p">,</span>
      <span class="n">layoutMargins</span><span class="p">:</span> <span class="n">UIEdgeInsets</span> <span class="p">=</span> <span class="n">UIEdgeInsets</span><span class="p">(</span><span class="n">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="kr">left</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="kr">right</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span>
      <span class="n">mask</span><span class="p">:</span> <span class="n">UIView</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span>
      <span class="n">motionEffects</span><span class="p">:</span> <span class="p">[</span><span class="n">UIMotionEffect</span><span class="p">]</span> <span class="p">=</span> <span class="p">[],</span>
      <span class="n">multipleTouchEnabled</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span>
      <span class="n">opaque</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span>
      <span class="n">preservesSuperviewLayoutMargins</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span>
      <span class="n">restorationIdentifier</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span>
      <span class="n">semanticContentAttribute</span><span class="p">:</span> <span class="n">UISemanticContentAttribute</span> <span class="p">=</span> <span class="p">.</span><span class="n">unspecified</span><span class="p">,</span>
      <span class="n">tag</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">tintAdjustmentMode</span><span class="p">:</span> <span class="n">UIViewTintAdjustmentMode</span> <span class="p">=</span> <span class="p">.</span><span class="n">automatic</span><span class="p">,</span>
      <span class="n">tintColor</span><span class="p">:</span> <span class="n">UIColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">white</span><span class="p">,</span>
      <span class="n">userInteractionEnabled</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span>
      <span class="n">verticalContentCompressionResistancePriority</span><span class="p">:</span> <span class="n">UILayoutPriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">defaultHigh</span><span class="p">,</span>
      <span class="n">verticalContentHuggingPriority</span><span class="p">:</span> <span class="n">UILayoutPriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">defaultLow</span>
   <span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The autocomplete feature in Xcode starts to get a little weird with this many defaulted parameters. Autocomplete issues might seem like a minor inconvenience but since the entire <em>purpose</em> of this construction code is supposed to be convenience, it merits consideration.</p>

<p>Another inconvenience is that Swift requires parameters be provided in-order. For long lists of properties, you&rsquo;d probably need to carefully keep things in alphabetical order to make it work - which is a hassle since properties like these are not inherently an ordered concept.</p>

<p>This approach really becomes strained when we look at inheritance hierarchies. There&rsquo;s as many as 30 properties you might set on a <code>UITextField</code>, plus 6 on <code>UIControl</code> plus the 25 on <code>UIView</code>. That&rsquo;s over <em>60 parameters</em> before we&rsquo;ve included actions, delegates and oddities like how to handle mutability, all of which would likely increase (and in the case of mutability <em>multiply</em>) the number of parameters required.</p>

<p>Now, Swift itself doesn&rsquo;t really mind if you pass hundreds or even thousands of defaulted parameters to a function. I generated a function with 10,000 parameters while writing this article and it appeared to work without issue.</p>

<p>The real problem with huge numbers of parameters is in <em>maintaining</em> all the constructors across multiple levels of subclass. If every <code>UIView</code> subclass has a constructor that needs to repeat every <code>UIView</code> property then every time <code>UIView</code> changes its set of properties, all <code>UIView</code> subclass constructors would need to be updated. This is completely unreasonable.</p>

<h2 id="enum-cases-as-parameter-names">Enum cases as parameter names</h2>

<p>Let&rsquo;s try a different approach. In my previous article, <a href="cwllayout.html">CwlLayout: a Swift wrapper around Auto Layout</a>, I showed a syntax where the parameters to a function were a variable argument list of <code>enum</code> cases. Here&rsquo;s how it looked:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">Layout</span><span class="p">.</span><span class="n">horizontal</span><span class="p">(</span>
   <span class="p">.</span><span class="n">sizedView</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span> <span class="p">.</span><span class="n">lengthEqualTo</span><span class="p">(</span><span class="n">ratio</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">)),</span>
   <span class="p">.</span><span class="n">space</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
   <span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="kr">right</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>We can use a similar approach here by creating an <code>enum</code> with all the properties from <code>UIView</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">ViewBinding</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">alpha</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">backgroundColor</span><span class="p">(</span><span class="n">UIColor</span><span class="p">?)</span>
   <span class="k">case</span> <span class="n">clearsContextBeforeDrawing</span><span class="p">(</span><span class="nb">Bool</span><span class="p">)</span>
   <span class="c1">// ... and so on</span>
<span class="p">}</span></code></pre></div>
<p>and then we can write an <code>init</code> function that accepts a variable number of these arguments:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">UIView</span> <span class="p">{</span>
   <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">bindings</span><span class="p">:</span> <span class="n">ViewBinding</span><span class="p">...)</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></div>
<p>and construct <code>UIView</code> like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UIView</span><span class="p">(</span>
   <span class="p">.</span><span class="n">alpha</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
   <span class="p">.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="n">white</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>This looks like it might be more promising. Parameters don&rsquo;t need to be provided in-order, it&rsquo;s not going to have the autocomplete problems in Xcode and it&rsquo;s not going to put hundreds of parameters onto the stack each time.</p>

<p>There&rsquo;s the slight weirdness that you could inadvertently provide two instances of the same parameter, e.g.:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UIView</span><span class="p">(</span>
   <span class="p">.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="n">white</span><span class="p">),</span>
   <span class="p">.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="n">blue</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>There shouldn&rsquo;t be any valid reason to do this but it isn&rsquo;t any worse than setting the same property twice in code – a waste of time but not a show stopping scenario.</p>

<p>A bigger problem is that there&rsquo;s no solution here for inheritance. If we had to exhaustively enumerate all <code>UIView</code> properties in each <code>UIView</code> subclass, then a change to <code>UIView</code> would still break every <code>UIView</code> subclass.</p>

<h2 id="enums-with-inheritance">Enums with inheritance</h2>

<p>We could wrap the parameters of the inherited class in an <code>inheritedBinding</code> case:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">TextFieldBinding</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">inheritedBinding</span><span class="p">(</span><span class="n">ControlBinding</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">text</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
   <span class="c1">// other UITextField properties</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">ControlBinding</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">inheritedBinding</span><span class="p">(</span><span class="n">ViewBinding</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">enabled</span><span class="p">(</span><span class="nb">Bool</span><span class="p">)</span>
   <span class="c1">// other UIControl properties</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">ViewBinding</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">alpha</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span>
   <span class="k">case</span> <span class="n">backgroundColor</span><span class="p">(</span><span class="n">UIColor</span><span class="p">?)</span>
   <span class="k">case</span> <span class="n">clearsContextBeforeDrawing</span><span class="p">(</span><span class="nb">Bool</span><span class="p">)</span>
   <span class="c1">// ... and so on</span>
<span class="p">}</span></code></pre></div>
<p>We could use this to create an <code>init</code> method on <code>UITextField</code> capable of this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">text</span><span class="p">(</span><span class="n">someTextValue</span><span class="p">),</span>
   <span class="p">.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">enabled</span><span class="p">(.</span><span class="kc">false</span><span class="p">)),</span>
   <span class="p">.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="n">white</span><span class="p">)))</span>
<span class="p">)</span></code></pre></div>
<p>Technically <em>works</em> but it&rsquo;s starting to get a little goofy. Needing to remember the correct inheritance level and correctly specify it is annoying and the real information on each line is starting to get a little lost in layers of wrapping.</p>

<p>Fortunately, Swift has the ability to look up <code>static</code> members using the dot operator so we could simplify this slightly by adding a <code>static</code> function on <code>TextFieldBinding</code> that shortcuts to any subclass:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">TextFieldBinding</span> <span class="p">{</span>
   <span class="kd">static</span> <span class="kd">func</span> <span class="nf">controlBinding</span><span class="p">(</span><span class="kc">_</span> <span class="n">Binding</span><span class="p">:</span> <span class="n">ControlBinding</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">TextFieldBinding</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">param</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="kd">static</span> <span class="kd">func</span> <span class="nf">viewBinding</span><span class="p">(</span><span class="kc">_</span> <span class="n">Binding</span><span class="p">:</span> <span class="n">ViewBinding</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">TextFieldBinding</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">inheritedBinding</span><span class="p">(.</span><span class="n">param</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>and we could rewrite the initialization as:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(.</span><span class="n">text</span><span class="p">(</span><span class="n">someTextValue</span><span class="p">))</span>
   <span class="p">.</span><span class="n">controlBinding</span><span class="p">(.</span><span class="n">isEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
   <span class="p">.</span><span class="n">viewBinding</span><span class="p">(.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="n">white</span><span class="p">))</span>
<span class="p">)</span></code></pre></div>
<p>The <code>.textFieldBinding</code> wrapper isn&rsquo;t required here but I&rsquo;ve included for consistency.</p>

<p>This does address the problems of inheritance and large numbers of defaulted parameters but the aesthetics are certainly not ideal. The property name that we&rsquo;re trying to set is buried in the <em>middle</em> of each line and there&rsquo;s two layers of parentheses required to wrap the contents.</p>

<p>And I&rsquo;ve been omitting the most important part: these parameters are constant and I want a solution that handles <em>dynamic</em> parameters.</p>

<h2 id="dynamic-values">Dynamic values</h2>

<p>We need to be able to satisfy any property with a <em>dynamic value</em> – a property that gets its value from a dynamic source, like a reactive programming signal. Of course, just because a property <em>can</em> be dynamic, doesn&rsquo;t mean it <em>must</em> be dynamic. This means that we need to be able to set any dynamic property in two different ways:</p>

<ul>
<li>Constant (e.g. a value like <code>.white</code>)</li>
<li>Dynamic (e.g. a signal like <code>signal.map { $0.isEditing ? .white : .lightGray }</code>)</li>
</ul>

<p>To handle these two scenarios, the associated values in our Binding <code>enum</code> values will no longer be simple types (like <code>String</code> or <code>UIColor</code> or <code>Bool</code>) and will instead be wrapped in <code>DynamicValue</code> so we can provide <code>.constant</code> or <code>.dynamic</code> versions:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">DynamicValue</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">case</span> <span class="n">constant</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span>
   <span class="k">case</span> <span class="kr">dynamic</span><span class="p">(</span><span class="n">Signal</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Our construction might then become:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(.</span><span class="n">text</span><span class="p">(.</span><span class="kr">dynamic</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
   <span class="p">))),</span>
   <span class="p">.</span><span class="n">controlBinding</span><span class="p">(.</span><span class="n">enabled</span><span class="p">(.</span><span class="kr">dynamic</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">}</span>
   <span class="p">))),</span>
   <span class="p">.</span><span class="n">viewBinding</span><span class="p">(.</span><span class="n">backgroundColor</span><span class="p">(.</span><span class="kr">dynamic</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span> <span class="p">}</span>
   <span class="p">)))</span>
<span class="p">)</span></code></pre></div>
<p>The <code>UITextField</code> owns the endpoints that keep the bindings alive. These endpoints are stored with the object itself using <code>objc_setAssociatedObject</code>. Since bindings must be created on construction – they cannot be added later – we can do this efficiently and set an associated storage only if the object has dynamic bindings that need to be retained.</p>

<p>Conceptually, this is what I want but it looks really clumsy and we&rsquo;re approaching a LISP-level of parentheses.</p>

<h2 id="hiding-dirty-work-in-the-type-system">Hiding dirty work in the type system</h2>

<p>Let&rsquo;s start by trying to hide the <code>.dynamic</code>/<code>.constant</code> wrapper.</p>

<p>There&rsquo;s an interesting trick for <code>enum</code> cases with associated values: if they are used <em>without</em> their associated values, they refer to their own construction function. For example, <code>TextFieldBinding.text</code> has the type <code>(DynamicValue&lt;String&gt;) -&gt; TextFieldBinding</code> (a function that constructs a <code>TextFieldBinding</code> from a <code>DynamicValue&lt;String&gt;</code>).</p>

<p>We can use this trick to build abstractions around our enum cases. For example, we could construct overloaded versions of the existing <code>viewBinding</code>, <code>controlBinding</code> and <code>textBinding</code> static functions – one that takes dynamic values and another that takes constant values.</p>

<p>Here&rsquo;s an example of an overload version of the <code>viewBinding</code> static function:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">TextFieldBinding</span> <span class="p">{</span>
   <span class="kd">static</span> <span class="kd">func</span> <span class="nf">viewBinding</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="kc">_</span> <span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">DynamicBinding</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ViewBinding</span><span class="p">,</span>
      <span class="kc">_</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">TextFieldBinding</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">inherited</span><span class="p">(.</span><span class="n">inherited</span><span class="p">(</span><span class="n">name</span><span class="p">(.</span><span class="n">constant</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
   <span class="p">}</span>
   <span class="kd">static</span> <span class="kd">func</span> <span class="nf">viewBinding</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="kc">_</span> <span class="n">name</span><span class="p">:</span> <span class="p">(</span><span class="n">DynamicBinding</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ViewBinding</span><span class="p">,</span>
      <span class="kc">_</span> <span class="n">value</span><span class="p">:</span> <span class="n">Signal</span><span class="p">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">TextFieldBinding</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">inherited</span><span class="p">(.</span><span class="n">inherited</span><span class="p">(</span><span class="n">name</span><span class="p">(.</span><span class="kr">dynamic</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>This is probably confusing to read but notice that the first of these overloads uses an unwrapped <code>Value</code> as the second parameter and returns a <code>.constant</code> at the center of the wrapping layers, whereas the second takes a <code>Signal&lt;Value&gt;</code> and wraps in <code>.dynamic</code>.</p>

<p>Here&rsquo;s the effect on the code:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(</span><span class="n">TextFieldBinding</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
   <span class="p">),</span>
   <span class="p">.</span><span class="n">controlBinding</span><span class="p">(</span><span class="n">ControlBinding</span><span class="p">.</span><span class="n">isEnabled</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">}</span>
   <span class="p">),</span>
   <span class="p">.</span><span class="n">viewBinding</span><span class="p">(</span><span class="n">ViewBinding</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span> <span class="p">}</span>
   <span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>Hmm. We <em>did</em> get rid of the <code>.constant</code>/<code>.dynamic</code> wrapper but we&rsquo;ve been forced to fully specify the type of the first parameter to <code>.textFieldBinding</code>/<code>.controlBinding</code>/<code>.viewBinding</code> because the expected parameter is now a function instead of a <code>TextFieldBinding</code>/<code>ControlBinding</code>/<code>ViewBinding</code> and because of this, we can&rsquo;t use <code>.</code> lookup.</p>

<p>That&rsquo;s a real nuisance. We made a syntactic saving in one spot only to lose most of it in another.</p>

<h2 id="intermediate-type">Intermediate type</h2>

<p>To get the <code>.</code> lookup back for the first parameter, we can use an intermediate type to provide a location for <code>.</code> lookup to occur and encapsulate the desired <code>(Value) -&gt; TextFieldBinding</code> function internally.</p>

<p>I&rsquo;m going to use a type named <code>BindingName</code> as the intermediate type. This type will be defined as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">struct</span> <span class="nc">BindingName</span><span class="p">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Binding</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">var</span> <span class="nv">constructor</span><span class="p">:</span> <span class="p">(</span><span class="n">Value</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Binding</span>
   <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">constructor</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">Value</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Binding</span><span class="p">)</span> <span class="p">{</span>
      <span class="kc">self</span><span class="p">.</span><span class="n">constructor</span> <span class="p">=</span> <span class="n">constructor</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="nc">BindingName</span> <span class="k">where</span> <span class="n">Binding</span><span class="p">:</span> <span class="n">TextFieldBinding</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kd">var</span> <span class="nv">text</span><span class="p">:</span> <span class="n">BindingName</span><span class="p">&lt;</span><span class="n">DynamicValue</span><span class="p">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Binding</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">BindingName</span><span class="p">&lt;</span><span class="n">DynamicValue</span><span class="p">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Binding</span><span class="o">&gt;</span><span class="p">({</span> <span class="n">v</span> <span class="k">in</span>
         <span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(</span><span class="n">TextField</span><span class="p">.</span><span class="n">Binding</span><span class="p">.</span><span class="n">text</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
      <span class="p">})</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The <code>constructor</code> property of this type can then be used by the <code>viewBinding</code>/<code>controlBinding</code>/<code>textFieldBinding</code> wrappers in place of the previous <code>name</code> function.</p>

<p>With this, <code>.text</code>, <code>.isEnabled</code> and <code>.backgroundColor</code> no longer require a full typename:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(.</span><span class="n">text</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
   <span class="p">),</span>
   <span class="p">.</span><span class="n">controlBinding</span><span class="p">(.</span><span class="n">isEnabled</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">}</span>
   <span class="p">),</span>
   <span class="p">.</span><span class="n">viewBinding</span><span class="p">(.</span><span class="n">backgroundColor</span><span class="p">,</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span> <span class="p">}</span>
   <span class="p">)</span>
<span class="p">)</span></code></pre></div>
<h2 id="a-little-operator-overloading">A little operator overloading</h2>

<p>This is <em>almost</em> what I want but I still don&rsquo;t like the fact that a wrapper function is the first visual element on each line. The only way to omit this wrapper in Swift is with operator overloading.</p>

<p>The idea is to replace the <code>textFieldBinding</code>, <code>controlViewBinding</code> and <code>viewBinding</code> wrapper functions with an operator overload that does the same work. I am not normally a fan of custom operators but I opted to use one here after becoming frustrated with scenarios involving huge numbers of closing parentheses (three or four closing parentheses becomes very difficult to read).</p>

<p>I opted to use the custom operator <code>--</code> (two hyphens) because it&rsquo;s easy to type, is very visually light and it resembles an em-dash which might be validly used for separating keys and values in a list. I realize that it is used to denote code comments in some languages but I don&rsquo;t think that&rsquo;s a major conceptual conflict for use as a key-value separator.</p>

<p>The final result is that the function looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">borderStyle</span> <span class="o">--</span> <span class="p">.</span><span class="n">roundedRect</span><span class="p">,</span>
   <span class="p">.</span><span class="n">enabled</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">backgroundColor</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">text</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">didChange</span> <span class="o">--</span> <span class="n">Input</span><span class="p">()</span>
      <span class="p">.</span><span class="n">triggerCombine</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span><span class="p">)</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="n">trigger</span><span class="p">,</span> <span class="nv">$0</span><span class="p">.</span><span class="n">sample</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>I&rsquo;ve included the the <code>.didChange</code> action binding here. Unlike the other bindings which model <em>setter</em> properties on the <code>UITextField</code>, this <code>.didChange</code> binding models a callback.</p>

<p>On a syntactic level, the only difference here is that instead of an <code>enum</code> case with a <code>DynamicValue&lt;T&gt;</code>, the <code>.didChange</code> case has an associated <code>SignalInput&lt;String&gt;</code>. An additional overload of the <code>--</code> operator matches this <code>SignalInput</code> scenario and ensures we provide the appropriate right-hand-side.</p>

<p>The right-hand-side of the <code>--</code> operator constructs a new <code>Input()</code> to receive the callback and the <code>String</code> parameter in the callback is combined with the <code>id</code> from the <code>ViewState.shared.personSignal</code> before sending a <code>setName</code> message through to the <code>Document</code> with a <code>bind(to:)</code> call.</p>

<h2 id="alternatives">Alternatives</h2>

<p>I&rsquo;ve gone back and forth on the design for this view construction syntax as much as any other code I&rsquo;ve written. If you&rsquo;re wondering why I didn&rsquo;t choose a different approach&hellip; I probably did, for a while, and either ran into a problem or otherwise grew to dislike something.</p>

<p>One of the obvious alternatives is avoiding the custom operator. It is possible to implement a version with all the same features but looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">text</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">}),</span>
   <span class="p">.</span><span class="n">enabled</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>My dislike of custom operators fought my dislike of parentheses and lost. It didn&rsquo;t help that this approach required multiple overloads of <em>each</em> binding name to allow dynamic/constant and other variants so it wasn&rsquo;t as extensible.</p>

<p>I also spent a long time using separate <code>&lt;--</code> and <code>--&gt;</code> operators for inputs and outputs. This was originally due to an older implementation where the operator overloads weren&rsquo;t scaling well. I split the operator to lighten the overload resolution burden on the type system. After some restructuring, the operator resolution performance improved but I kept the separate operators for a while. Showing a direction for &ldquo;inputs&rdquo; and &ldquo;outputs&rdquo; might seem helpful but the types, the parameter names and the values you supply already indicate the direction of data flow and I liked the much plainer key-value styling of using <code>--</code> everywhere, rather than trying to be visually clever about it.</p>

<h2 id="drawbacks">Drawbacks</h2>

<p>It&rsquo;s usually not a good idea to use an overloaded operator like <code>--</code> inside array-literal square brackets. Past a half dozen values it can start to resolve slowly. This is a problem that <em>could</em> occur by accident if you&rsquo;re not paying attention. If you want to construct an array of these bindings, construct the array on its own line and assign to a variable with a fully specified type – Swift uses optimized type inference in this scenario.</p>

<p>There&rsquo;s a related problem when constructing a large generic type using this syntax. If resolving the <code>--</code> terms is required to resolve the generic parameters, it&rsquo;s not going to scale past a dozen or so parameters. Far better to explicitly specify your generic parameters.</p>

<p>Variable argument lists <em>really</em> confuse the Swift compilation error reporting mechanism. Accidentally omit a comma, add an extra comma, mix up your types, or make some other typo and the Swift compiler might:</p>

<ul>
<li>suggest you fix the second argument (even if the error is in the 20th argument)</li>
<li>suggest you add a parameter name, even though no parameters should be named</li>
<li>complain about being unable to resolve generic parameters that are explicitly specified</li>
<li>complain that there are too many arguments in your variable argument list</li>
</ul>

<p>As an example, during the writing of this article, I accidentally wrote:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="p">.</span><span class="n">borderStyle</span> <span class="o">--</span> <span class="p">.</span><span class="n">roundRect</span><span class="p">,</span></code></pre></div>
<p>when the correct spelling is:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="p">.</span><span class="n">borderStyle</span> <span class="o">--</span> <span class="p">.</span><span class="n">roundedRect</span><span class="p">,</span></code></pre></div>
<p>Swift&rsquo;s error message was &ldquo;Generic parameter &lsquo;Interface&rsquo; could not be inferred&rdquo;. <code>Interface</code> is a generic parameter on one of the <code>--</code> operator overloads – but it&rsquo;s on a <em>different</em> overload to the one you&rsquo;d expect, here. The error message might as well be Swift shrugging its shoulders &ldquo;Um&hellip; not sure?&rdquo;</p>

<p>With this type of code, you need to consider that any error reported by the compiler may point to the wrong location or otherwise indicate that the compiler has no idea at all what&rsquo;s gone wrong. There are plenty of cases where I&rsquo;ve needed to comment out parameter lines to narrow down the location of the problem.</p>

<p>If you&rsquo;re having difficulty isolating <em>why</em> a compiler error is occurring in a given line, you can always replace the optimized syntax:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="p">.</span><span class="n">borderStyle</span> <span class="o">--</span> <span class="p">.</span><span class="n">roundedRect</span><span class="p">,</span></code></pre></div>
<p>with the verbose syntax:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(.</span><span class="n">borderStyle</span><span class="p">(.</span><span class="n">constant</span><span class="p">(.</span><span class="n">roundedRect</span><span class="p">))),</span></code></pre></div>
<p>Swift tends to give much better error reporting as you start to make things more explicit. Theoretically, you could be <em>completely</em> explicit:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">TextField</span><span class="p">.</span><span class="n">Binding</span><span class="p">.</span><span class="n">textFieldBinding</span><span class="p">(</span>
   <span class="n">TextField</span><span class="p">.</span><span class="n">Binding</span><span class="p">.</span><span class="n">borderStyle</span><span class="p">(</span>
      <span class="n">DynamicValue</span><span class="p">&lt;</span><span class="n">UITextFieldBorderStyle</span><span class="o">&gt;</span><span class="p">.</span><span class="n">constant</span><span class="p">(</span>
         <span class="n">UITextFieldBorderStyle</span><span class="p">.</span><span class="n">roundedRect</span>
      <span class="p">)</span>
   <span class="p">)</span>
<span class="p">),</span></code></pre></div>
<p>although I&rsquo;ve never had to go that far and there&rsquo;s a reason why we want the compiler to do this work for us.</p>

<p>Take another look at that last code sample. We need only write <code>.borderStyle -- .roundedRect</code> and the compiler fills in the remainder – that&rsquo;s what this article is all about.</p>

<h2 id="usage">Usage</h2>

<p>You can play with some of the examples in this article in the <a href="https://github.com/mattgallagher/CocoaWithLovePlaygrounds">ViewConstruction.playground</a>. The playground builds the following view:</p>

<p><img src="../assets/blog/viewconstructor.png" alt="" /></p>

<p>The <code>nameField</code> discussed in this article is visible at the top, along with some basic controls to alter the View-state and the Document to observe the effects on the <code>UITextField</code>.</p>

<p>The playground includes three different code paths that can construct this <code>UITextField</code>:</p>

<ul>
<li>standard Cocoa <code>cocoaViews</code></li>
<li>reactive programming <code>reactiveViews</code></li>
<li>the <code>cwlViews</code> approach</li>
</ul>

<p>They should all appear the same to the user.</p>

<p>The &ldquo;Sources&rdquo; folder in the playground contains a collection of files hastily butchered from CwlViews and a lazily constructed &ldquo;Model&rdquo; to provide the <code>ViewState</code> and <code>Document</code> in the examples. The result is not easy to read and the only purpose is to keep the actual playground page functional. The purpose of this playground is purely to present the ViewContruction playground page itself.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I aimed to construct a view in a single, self-contained expression using a syntax that resembled a declarative description of properties. The result is the following syntax:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">UITextField</span><span class="p">(</span>
   <span class="p">.</span><span class="n">borderStyle</span> <span class="o">--</span> <span class="p">.</span><span class="n">roundedRect</span><span class="p">,</span>
   <span class="p">.</span><span class="n">enabled</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">backgroundColor</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">isEditing</span> <span class="p">?</span> <span class="p">.</span><span class="n">white</span> <span class="p">:</span> <span class="p">.</span><span class="n">lightGray</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">text</span> <span class="o">--</span> <span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span>
      <span class="p">.</span><span class="n">flatMapLatest</span> <span class="p">{</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">signalForPerson</span><span class="p">(</span><span class="n">withId</span><span class="p">:</span> <span class="nv">$0</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">name</span> <span class="p">},</span>
   <span class="p">.</span><span class="n">didChange</span> <span class="o">--</span> <span class="n">Input</span><span class="p">()</span>
      <span class="p">.</span><span class="n">triggerCombine</span><span class="p">(</span><span class="n">ViewState</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">personSignal</span><span class="p">)</span>
      <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="n">trigger</span><span class="p">,</span> <span class="nv">$0</span><span class="p">.</span><span class="n">sample</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">Document</span><span class="p">.</span><span class="n">shared</span><span class="p">)</span>
<span class="p">)</span></code></pre></div>
<p>The result is 14 lines, versus 11 lines in the original text description. It&rsquo;s less than half the length of common Cocoa code to achieve the same result with significantly clearer structure.</p>

<p>It&rsquo;s possible that the right-hand side might look cluttered or cryptic if you&rsquo;re unfamiliar with reactive programming. However, even if you can&rsquo;t read code at all, the structure of the code should reveal what it does: it is a list of 5 properties (<code>.borderStyle</code>, <code>.enabled</code>, <code>.backgroundColor</code>, <code>.text</code> and <code>.didChange</code>) that we&rsquo;re specifying on a <code>UITextField</code>.</p>

<p>If you do understand code and you know how verbose and unstructured this type of code can be, then you should appreciate how clearly and succinctly it is expressed. Inherited properties, constant or dynamic sources, inputs or outputs – all are possible while maintaining a clean, minimal aesthetic.</p>

<p>I did use a custom operator. I&rsquo;m normally opposed to custom operators and I will often dismiss others&rsquo; code involving custom operators on the grounds that they makes things needlessly cryptic. I&rsquo;m sure some programmers will look at this code and immediately dismiss it for the same reasons. I hope that most programmers will see that I&rsquo;m not trying to be fancy with the custom operator; in fact it&rsquo;s the best way to keep things simple.</p>

<p>The <code>.parameter -- value</code> syntax is intended to read like a standard <code>parameter: value</code> argument list, it just offers the ability to hide some boilerplate wrappers and handle a wider range of scenarios automatically.</p>

<h3 id="looking-forward">Looking forward</h3>

<p>This syntax is one aspect of the CwlViews framework. While I&rsquo;m still scrambling to finish the framework itself, I&rsquo;ll spend the next article talking a little about the impact on a program when its views have their behaviors fully specified and can entirely self-manage after construction.</p>

		</div>
	</article>
</main>

<div class="pagination">
  <div class="page-prev">
    Previous article:<br/><a href="view-state-driven-applications.html">View-state driven applications</a>
  </div>
  <div class="page-next">
    Next article:<br/><a href="mvc-without-the-c.html">Model-View-Controller without the Controller</a>
  </div>
</div>


</div>
</div>

<footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Subscribe: <a href="../feed.json">JSON</a>, <a href="../feed.xml.rss">RSS</a> or <a href="https://apple.news/ToAaeVKb9TJOyYZi4sXnvXg">Apple News</a></li>
          <li>Twitter: <a href="https://twitter.com/cocoawithlove">@cocoawithlove</a></li>
          <li>Github: <a href="https://github.com/mattgallagher">mattgallagher</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>&copy; 2008-2018 Matt Gallagher. All rights reserved.<br/>Code may be used in accordance with license on <a href="../about/index.html">About</a> page.<br/>If you need to contact me: <script type="text/javascript">
e1=('cocoa' + 'with' + 'love' + '&#46' + 'com')
e2=('info' + '&#64')
document.write('<a href="mailto:' + e2 + e1 + '">' + e2 + e1 + '</a>')
</script></p>
      </div>
    </div>

  </div>

</footer>

</body>

</html>
